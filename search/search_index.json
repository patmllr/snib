{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to snib","text":"<p><code>snib</code> is a tool for generating prompt-ready text files from your codebase.</p> <ul> <li>Usage docs: Learn how to run snib and configure it.</li> <li>Development docs: Contributing, testing, and internal structure.</li> <li>API Reference docs: Automatically generated from the code docstrings.</li> </ul>"},{"location":"development/changelog/","title":"Changelog","text":"<p>Content coming soon.</p>"},{"location":"development/code_structure/","title":"Code Structure","text":"<p>Content coming soon.</p>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/contributing/#presets","title":"Presets","text":"<p>Community contributions of new presets or improvements are welcome! </p> <p>Submitting a preset</p> <ol> <li>Fork the repository.</li> <li>Add your preset file in src/snib/presets/ (e.g., rust.toml, go.toml, terraform.toml).</li> <li>Make sure your preset:<ul> <li>Uses a descriptive filename (e.g., <code>rust.toml</code>, not <code>preset1.toml</code>).</li> <li>Contains a clear <code>[config]</code> section.</li> <li>Has meaningful include / exclude rules.</li> <li>Has been tested locally.</li> </ul> </li> <li>Open a Pull Request against the <code>staging</code> branch with a short explanation of:<ul> <li>The project type the preset is for.</li> <li>Any specifics about the filters.</li> </ul> </li> </ol> <p>Why contribute presets?</p> <p>Presets are the easiest way to contribute - even if you don\u2019t know Python!</p>"},{"location":"development/contributing/#bugs","title":"Bugs","text":"<p>We appreciate help identifying and fixing bugs! You can contribute by reporting issues or submitting bugfixes.</p> <p>Reporting a bug</p> <ol> <li>Check the Issues Tracker to see if the bug has already been reported.</li> <li>Open a new issue with a clear description, including:<ul> <li>Steps to reproduce the bug</li> <li>Expected vs actual behavior</li> <li>Any relevant logs or error messages</li> </ul> </li> <li>Label the issue appropriately (e.g., bug).</li> </ol> <p>Fixing a bug</p> <ol> <li>Fork the repository</li> <li>Create a branch for your bugfix: <code>git checkout -b fix/short-description</code></li> <li>Implement and commit your changes: <code>git commit -m \"fix(component): brief description of fix\"</code></li> <li>Push your branch to your fork: <code>git push origin fix/short-description</code></li> <li>Open a Pull Request against the <code>staging</code> branch.</li> </ol>"},{"location":"development/contributing/#features","title":"Features","text":"<p>To contribute a new feature, please follow these steps:</p> <p>Adding a feature</p> <ol> <li>Fork this repository  </li> <li>Create a dedicated branch: <code>git checkout -b feature/your-feature</code> </li> <li>Implement and commit your changes: <code>git commit -m \"feat(your-feature): add new feature ...\"</code> </li> <li>Push your branch to your fork: <code>git push origin feature/your-feature</code> </li> <li>Open a Pull Request against the <code>staging</code> branch</li> </ol> <p>Why use the stagin branch?</p> <p>Pull Requests are tested on the <code>staging</code> branch first. Once everything works, changes will be merged into <code>main</code>.</p>"},{"location":"development/contributing/#commit-message-convention","title":"Commit Message Convention","text":"<p>We follow the Conventional Commits format:</p> <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;short description&gt;\n\n[optional longer body]\n</code></pre>"},{"location":"development/contributing/#types","title":"Types","text":"Type Purpose Example feat A new feature <code>feat(cli): add command</code> fix A bug fix <code>fix(_match_patterns): globs</code> docs Documentation only <code>docs(readme): update links</code> style Code style (formatting, whitespace, etc.), no logic changes <code>style(balck): apply black</code> refactor Code change that neither fixes a bug nor adds a feature <code>refactor(pipeline): simplify</code> test Adding or updating tests <code>test(scanner): add tests</code> chore Maintenance, CI/CD, build, dependencies <code>chore(ci): add new workflow</code>"},{"location":"development/contributing/#guidelines","title":"Guidelines","text":"<p>Make your commits easier to understand</p> <ul> <li>Write commit messages in the imperative mood (e.g., \u201cadd feature\u201d instead of \u201cadded\u201d or \u201cadds\u201d).</li> <li>Keep the first line under 72 characters.</li> <li>The scope  is optional but recommended. <li>Use the body to explain why the change was made, not just what was done.</li> <li>Aim for clarity and consistency.</li>"},{"location":"development/testing/","title":"Testing","text":"<p>Content coming soon.</p>"},{"location":"reference/chunker/","title":"Chunker","text":""},{"location":"reference/chunker/#snib.chunker.Chunker","title":"<code>snib.chunker.Chunker(chunk_size)</code>","text":"<p>A utility class to split formatted sections into smaller chunks for processing by LLMs.</p> <p>Each chunk will not exceed <code>chunk_size</code> characters (including a reserved header space), which helps to manage input limits for AI models.</p> <p>Initialize a Chunker instance.</p> <p>Parameters:</p> Name Type Description Default <code>chunk_size</code> <code>int</code> <p>Maximum character length of each chunk, including header.</p> required Source code in <code>src/snib/chunker.py</code> <pre><code>def __init__(self, chunk_size):\n    \"\"\"\n    Initialize a Chunker instance.\n\n    Args:\n        chunk_size (int): Maximum character length of each chunk, including header.\n    \"\"\"\n    self.chunk_size = chunk_size\n    self.header_size = 100  # reserve space for header\n</code></pre>"},{"location":"reference/chunker/#snib.chunker.Chunker.chunk","title":"<code>chunk(sections)</code>","text":"<p>Split a list of formatted sections into chunks of manageable size.</p> <p>The method respects the reserved header space and tries to avoid splitting lines in the middle.</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>list[str]</code> <p>Formatted sections.</p> required <p>Returns:</p> Type Description <p>list[str]: A list of string chunks, each &lt;= <code>chunk_size</code> characters including header.</p> Source code in <code>src/snib/chunker.py</code> <pre><code>def chunk(self, sections):\n    \"\"\"\n    Split a list of formatted sections into chunks of manageable size.\n\n    The method respects the reserved header space and tries to avoid splitting lines in the middle.\n\n    Args:\n        sections (list[str]): Formatted sections.\n\n    Returns:\n        list[str]: A list of string chunks, each &lt;= `chunk_size` characters including header.\n    \"\"\"\n    logger.info(\n        f\"Using chunk_size={self.chunk_size} chars \"\n        f\"(\u2248 {self.chunk_size // 4}-{self.chunk_size // 3} tokens estimated)\"\n    )\n\n    chunks = []\n    current_chunk = \"\"\n    for section in sections:\n        lines = section.splitlines(keepends=True)\n        for line in lines:\n            if len(current_chunk) + len(line) + self.header_size &gt; self.chunk_size:\n                chunks.append(current_chunk)\n                current_chunk = \"\"\n            current_chunk += line\n    if current_chunk:\n        chunks.append(current_chunk)\n\n    logger.info(f\"Created {len(chunks)} chunk(s)\")\n\n    return chunks\n</code></pre>"},{"location":"reference/formatter/","title":"Formatter","text":""},{"location":"reference/formatter/#snib.formatter.Formatter","title":"<code>snib.formatter.Formatter</code>","text":"<p>Formatter converts project sections into prompt-ready text.</p> <p>This class processes a list of Section objects (info, description, task, filters, project tree, file contents) and formats them into text blocks suitable for AI prompting. It also provides helper functions to format statistics about included/excluded files.</p>"},{"location":"reference/formatter/#snib.formatter.Formatter._format_stats","title":"<code>_format_stats(stats)</code>","text":"<p>Format FilterStats for human-readable output.</p> <p>Shows number of files and total size using readable units. (B/KB/MB/GB)</p> <p>Parameters:</p> Name Type Description Default <code>stats</code> <code>FilterStats</code> <p>Statistics object containing file count and total size in bytes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted string, e.g. \"files: 10, total size: 2.5 MB\".</p> Source code in <code>src/snib/formatter.py</code> <pre><code>def _format_stats(self, stats: FilterStats) -&gt; str:\n    \"\"\"\n    Format FilterStats for human-readable output.\n\n    Shows number of files and total size using readable units. (B/KB/MB/GB)\n\n    Args:\n        stats (FilterStats): Statistics object containing file count\n            and total size in bytes.\n\n    Returns:\n        str: Formatted string, e.g. \"files: 10, total size: 2.5 MB\".\n    \"\"\"\n    return f\"files: {stats.files}, total size: {format_size(stats.size)}\"\n</code></pre>"},{"location":"reference/formatter/#snib.formatter.Formatter.to_prompt_text","title":"<code>to_prompt_text(sections)</code>","text":"<p>Convert a list of Section objects into a list of prompt-ready strings.</p> <p>Each section type is formatted differently: - info: general information about the project - description: project description - task: AI task instructions - filters: included/excluded patterns with statistics - tree: project folder tree - file: actual file content with path header</p> <p>Parameters:</p> Name Type Description Default <code>sections</code> <code>list[Section]</code> <p>A list of Section objects representing different parts of the project scan.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of formatted strings, each representing a section. (This gets passed to the chunker.)</p> Notes <ul> <li>INFO, DESCRIPTION and TASK sections are skipped if empty.</li> </ul> Source code in <code>src/snib/formatter.py</code> <pre><code>def to_prompt_text(self, sections: list[Section]) -&gt; list[str]:\n    \"\"\"\n    Convert a list of Section objects into a list of prompt-ready strings.\n\n    Each section type is formatted differently:\n    - info: general information about the project\n    - description: project description\n    - task: AI task instructions\n    - filters: included/excluded patterns with statistics\n    - tree: project folder tree\n    - file: actual file content with path header\n\n    Args:\n        sections (list[Section]): A list of Section objects representing\n            different parts of the project scan.\n\n    Returns:\n        list[str]: A list of formatted strings, each representing a\n            section. (This gets passed to the chunker.)\n\n    Notes:\n        - INFO, DESCRIPTION and TASK sections are skipped if empty.\n    \"\"\"\n\n    texts = []\n    for s in sections:\n        if s.type == \"info\":\n            if s.content:\n                texts.append(f\"#[INFO]\\n{s.content}\\n\")\n            else:\n                logger.info(\"Only one prompt file; skipping INFO section.\")\n        elif s.type == \"description\":\n            if s.content:\n                texts.append(f\"#[DESCRIPTION]\\n{s.content}\\n\\n\")\n            else:\n                logger.info(\n                    \"No description provided; skipping DESCRIPTION section.\"\n                )\n        elif s.type == \"task\":\n            if s.content:\n                texts.append(f\"#[TASK]\\n{s.content}\\n\\n\")\n            else:\n                logger.info(\"No task specified; skipping TASK section.\")\n        elif s.type == \"filters\":\n            include_text = s.include if s.include else \"\"\n            exclude_text = s.exclude if s.exclude else \"\"\n            include_stats_text = (\n                self._format_stats(s.include_stats) if s.include_stats else \"\"\n            )\n            exclude_stats_text = (\n                self._format_stats(s.exclude_stats) if s.exclude_stats else \"\"\n            )\n\n            texts.append(\n                f\"#[INCLUDE/EXCLUDE]\\n\"\n                f\"Include patterns: {include_text}\\n\"\n                f\"Exclude patterns: {exclude_text}\\n\"\n                f\"Included files: {include_stats_text}\\n\"\n                f\"Excluded files: {exclude_stats_text}\\n\\n\"\n            )\n        elif s.type == \"tree\":\n            texts.append(f\"#[PROJECT TREE]\\n{s.content}\\n\\n\")\n        elif s.type == \"file\":\n            texts.append(f\"#[FILE] {s.path}\\n{s.content}\\n\\n\")\n    return texts\n</code></pre>"},{"location":"reference/logger/","title":"Logger","text":""},{"location":"reference/logger/#snib.logger.SnibLogger","title":"<code>snib.logger.SnibLogger</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Custom Logger for Snib with CONFIRM and NOTICE levels.</p> <p>This logger extends the standard Python logging.Logger and adds: - <code>notice()</code>: logs a NOTICE-level message (custom level 26). - <code>confirm()</code>: prompts the user with a yes/no question, logging it at CONFIRM level (custom level 25).</p> <p>The logger supports standard levels: DEBUG, INFO, WARNING, ERROR, plus the custom levels.</p>"},{"location":"reference/logger/#snib.logger.SnibLogger.confirm","title":"<code>confirm(msg, default=False)</code>","text":"<p>Prompts the user with a yes/no confirmation and returns the response.</p> <p>Logs the prompt at CONFIRM level (custom level 25) and prints a formatted prefix. Loops until the user enters a valid response.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message/question to display to the user.</p> required <code>default</code> <code>bool</code> <p>The default value if the user presses Enter without typing 'y' or 'n'. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if user confirms, False otherwise.</p> Source code in <code>src/snib/logger.py</code> <pre><code>def confirm(self, msg: str, default: bool = False) -&gt; bool:\n    \"\"\"\n    Prompts the user with a yes/no confirmation and returns the response.\n\n    Logs the prompt at CONFIRM level (custom level 25) and prints a\n    formatted prefix. Loops until the user enters a valid response.\n\n    Args:\n        msg (str): The message/question to display to the user.\n        default (bool): The default value if the user presses Enter\n            without typing 'y' or 'n'. Defaults to False.\n\n    Returns:\n        bool: True if user confirms, False otherwise.\n    \"\"\"\n    if self.isEnabledFor(CONFIRM_LEVEL):\n        # build prefix for log-record\n        if self.handlers:\n            frame = inspect.currentframe().f_back\n            record = logging.LogRecord(\n                name=self.name,\n                level=CONFIRM_LEVEL,\n                pathname=frame.f_code.co_filename,\n                lineno=frame.f_lineno,\n                msg=msg,\n                args=(),\n                exc_info=None,\n            )\n            prefix = self.handlers[0].formatter.format(record)\n        else:\n            prefix = f\"[CONFIRM] {self.name}: {msg}\"\n\n        # prompt\n        prompt_text = f\"{prefix} [y/N]: \"\n        while True:\n            response = input(prompt_text).strip().lower()\n            if response == \"\":\n                return default\n            if response in (\"y\", \"yes\"):\n                return True\n            if response in (\"n\", \"no\"):\n                return False\n            self.info(\"Please enter Y or N.\")\n</code></pre>"},{"location":"reference/logger/#snib.logger.SnibLogger.notice","title":"<code>notice(msg, *args, **kwargs)</code>","text":"<p>Logs a message at NOTICE level (custom level 26).</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log.</p> required <code>*args</code> <p>Additional positional arguments for the logger.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments for the logger.</p> <code>{}</code> Source code in <code>src/snib/logger.py</code> <pre><code>def notice(self, msg: str, *args, **kwargs):\n    \"\"\"\n    Logs a message at NOTICE level (custom level 26).\n\n    Args:\n        msg (str): The message to log.\n        *args: Additional positional arguments for the logger.\n        **kwargs: Additional keyword arguments for the logger.\n    \"\"\"\n    if self.isEnabledFor(NOTICE_LEVEL):\n        self._log(NOTICE_LEVEL, msg, args, **kwargs)\n</code></pre>"},{"location":"reference/logger/#snib.logger.ColoredFormatter","title":"<code>snib.logger.ColoredFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Formatter that applies colors to log output based on level.</p> Uses Typer colors to style <ul> <li>DEBUG: Blue</li> <li>INFO: Green</li> <li>WARNING: Yellow</li> <li>ERROR: Red</li> <li>CONFIRM: Magenta</li> <li>NOTICE: Cyan</li> </ul> <p>Also dims the logger name in bright black.</p>"},{"location":"reference/logger/#snib.logger.ColoredFormatter.format","title":"<code>format(record)</code>","text":"<p>Formats a log record with colored levelname and logger name.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The record to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted and colored log string.</p> Source code in <code>src/snib/logger.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"\n    Formats a log record with colored levelname and logger name.\n\n    Args:\n        record (logging.LogRecord): The record to format.\n\n    Returns:\n        str: The formatted and colored log string.\n    \"\"\"\n    record.levelname = typer.style(\n        record.levelname, fg=LEVEL_COLORS.get(record.levelno, typer.colors.WHITE)\n    )\n    record.name = typer.style(record.name, fg=typer.colors.BRIGHT_BLACK)\n    return super().format(record)\n</code></pre>"},{"location":"reference/logger/#snib.logger.set_verbose","title":"<code>snib.logger.set_verbose(verbose)</code>","text":"<p>Set the logging verbosity for the global logger.</p> <p>Adjusts levels for all handlers and applies a colored format.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>If True, sets level to DEBUG, else INFO.</p> required Notes <ul> <li>Verbose mode also includes timestamp and module info.</li> <li>Normal mode shows only level and message.</li> </ul> Source code in <code>src/snib/logger.py</code> <pre><code>def set_verbose(verbose: bool):\n    \"\"\"\n    Set the logging verbosity for the global logger.\n\n    Adjusts levels for all handlers and applies a colored format.\n\n    Args:\n        verbose (bool): If True, sets level to DEBUG, else INFO.\n\n    Notes:\n        - Verbose mode also includes timestamp and module info.\n        - Normal mode shows only level and message.\n    \"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logger.setLevel(level)\n    for h in logger.handlers:\n        h.setLevel(level)\n        fmt = (\n            \"[%(levelname)s] [%(asctime)s] %(name)s.%(module)s: %(message)s\"\n            if verbose\n            else \"[%(levelname)s] %(message)s\"\n        )\n        h.setFormatter(ColoredFormatter(fmt, datefmt=\"%H:%M:%S\"))\n</code></pre>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/models/#snib.models.FilterStats","title":"<code>snib.models.FilterStats(type, files=0, size=0)</code>  <code>dataclass</code>","text":"<p>Stores statistics about files matched by include/exclude filters.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Type of statistics, e.g., \"included\" or \"excluded\".</p> <code>files</code> <code>int</code> <p>Number of files matching the filter. Defaults to 0.</p> <code>size</code> <code>int</code> <p>Total size in bytes of all files matching the filter. Defaults to 0.</p>"},{"location":"reference/models/#snib.models.Section","title":"<code>snib.models.Section(type, content='', path=None, include=None, exclude=None, include_stats=None, exclude_stats=None)</code>  <code>dataclass</code>","text":"<p>Represents a section of a project for prompt generation.</p> <p>Sections can represent various elements like description, task, filtered files, project tree, or individual files.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Section type, e.g., \"description\", \"task\", \"filters\", \"tree\", \"file\", \"info\".</p> <code>content</code> <code>str</code> <p>The textual content of the section. Defaults to empty string.</p> <code>path</code> <code>Optional[Path]</code> <p>Path of the file if section represents a file. Defaults to None.</p> <code>include</code> <code>Optional[list[str]]</code> <p>List of included patterns (for filter sections). Defaults to None.</p> <code>exclude</code> <code>Optional[list[str]]</code> <p>List of excluded patterns (for filter sections). Defaults to None.</p> <code>include_stats</code> <code>Optional[FilterStats]</code> <p>Statistics for included files. Defaults to None.</p> <code>exclude_stats</code> <code>Optional[FilterStats]</code> <p>Statistics for excluded files. Defaults to None.</p>"},{"location":"reference/pipeline/","title":"Pipeline","text":""},{"location":"reference/pipeline/#snib.pipeline.SnibPipeline","title":"<code>snib.pipeline.SnibPipeline</code>","text":"<p>Core pipeline class for initializing, scanning, and cleaning.</p> <p>Handles all app.commands: - <code>init</code>: creates project configuration and prompts folder. - <code>scan</code>: performs file collection, filtering, and chunking. - <code>clean</code>: deletes configuration files and/or output folders.</p>"},{"location":"reference/pipeline/#snib.pipeline.SnibPipeline.clean","title":"<code>clean(path, force, config_only, output_only)</code>","text":"<p>Cleans project by removing the <code>snibconfig.toml</code> and/or <code>prompts</code> folder.</p> <p>Default behavior deletes both config and output folder unless restricted by flags.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Project directory.</p> required <code>force</code> <code>bool</code> <p>If True, skips confirmation prompts.</p> required <code>config_only</code> <code>bool</code> <p>If True, only deletes <code>snibconfig.toml</code>.</p> required <code>output_only</code> <code>bool</code> <p>If True, only deletes <code>prompts/</code> folder.</p> required <p>Raises:</p> Type Description <code>Exit</code> <p>If no files/folders to delete or operation aborted by user.</p> <code>Exit</code> <p>If conflicting flags are provided (<code>config_only</code> and <code>output_only</code>).</p> Source code in <code>src/snib/pipeline.py</code> <pre><code>def clean(self, path: Path, force: bool, config_only: bool, output_only: bool):\n    \"\"\"\n    Cleans project by removing the `snibconfig.toml` and/or `prompts` folder.\n\n    Default behavior deletes both config and output folder unless restricted by flags.\n\n    Args:\n        path (Path): Project directory.\n        force (bool): If True, skips confirmation prompts.\n        config_only (bool): If True, only deletes `snibconfig.toml`.\n        output_only (bool): If True, only deletes `prompts/` folder.\n\n    Raises:\n        typer.Exit: If no files/folders to delete or operation aborted by user.\n        typer.Exit: If conflicting flags are provided (`config_only` and `output_only`).\n    \"\"\"\n\n    config_path = path / SNIB_CONFIG_FILE\n    output_dir = path / SNIB_PROMPTS_DIR\n\n    # checks flag conflicts\n    if config_only and output_only:\n        logger.error(\"--config-only and --output-only cannot be used together.\")\n        raise typer.Exit()\n\n    to_delete = []\n\n    if config_only:\n        if config_path.exists():\n            to_delete.append(config_path)\n    elif output_only:\n        if output_dir.exists():\n            to_delete.append(output_dir)\n    else:\n        if config_path.exists():\n            to_delete.append(config_path)\n        if output_dir.exists():\n            to_delete.append(output_dir)\n\n    if not to_delete:\n        logger.info(\"Nothing to clean. No matching files/folders found.\")\n        raise typer.Exit()\n\n    logger.info(\"The following will be deleted:\")\n    for item in to_delete:\n        logger.info(f\"- {item}\")\n\n    if not force:\n        confirm = logger.confirm(\"Do you want to proceed?\", default=False)\n        if not confirm:\n            logger.info(\"Aborted.\")\n            raise typer.Exit()\n\n    for item in to_delete:\n        if item.is_dir():\n            shutil.rmtree(item)\n            logger.notice(f\"Deleted: {item}\")\n        else:\n            item.unlink()\n            logger.notice(f\"Deleted: {item}\")\n</code></pre>"},{"location":"reference/pipeline/#snib.pipeline.SnibPipeline.init","title":"<code>init(path=Path.cwd(), preset=None, custom_preset=None)</code>","text":"<p>Initializes Snib in the given project directory.</p> <p>Creates a <code>snibconfig.toml</code> using: - a built-in default, - a named preset, or - a custom TOML file.</p> <p>Ensures that a <code>prompts/</code> folder exists. Skips creation if files/folders already exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Project directory to initialize. Defaults to current working directory.</p> <code>cwd()</code> <code>preset</code> <code>str</code> <p>Name of a built-in preset to use. Defaults to None.</p> <code>None</code> <code>custom_preset</code> <code>Path</code> <p>Path to a custom preset TOML file. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exit</code> <p>If both <code>preset</code> and <code>custom_preset</code> are provided, or if errors occur.</p> Source code in <code>src/snib/pipeline.py</code> <pre><code>def init(\n    self, path: Path = Path.cwd(), preset: str = None, custom_preset: Path = None\n):\n    \"\"\"\n    Initializes Snib in the given project directory.\n\n    Creates a `snibconfig.toml` using:\n    - a built-in default,\n    - a named preset, or\n    - a custom TOML file.\n\n    Ensures that a `prompts/` folder exists. Skips creation if files/folders already exist.\n\n    Args:\n        path (Path, optional): Project directory to initialize. Defaults to current working directory.\n        preset (str, optional): Name of a built-in preset to use. Defaults to None.\n        custom_preset (Path, optional): Path to a custom preset TOML file. Defaults to None.\n\n    Raises:\n        typer.Exit: If both `preset` and `custom_preset` are provided, or if errors occur.\n    \"\"\"\n\n    config_path = path / SNIB_CONFIG_FILE\n    prompts_dir = path / SNIB_PROMPTS_DIR\n\n    # check flags conflict\n    if preset and custom_preset:\n        logger.error(\"--preset and --custom-preset cannot be used together.\")\n        raise typer.Exit()\n\n    # check if config already exists else load and write config\n    if config_path.exists():\n        logger.error(f\"{SNIB_CONFIG_FILE} already exists at {config_path}\")\n        config_exists = True\n\n    else:\n        if preset:\n            data = load_preset(preset)\n        elif custom_preset:\n            if not custom_preset.exists():\n                logger.error(f\"Custom preset '{custom_preset}' not found.\")\n                raise typer.Exit()\n            data = load_config(custom_preset)\n        else:\n            data = SNIB_DEFAULT_CONFIG\n\n        data = check_config(data)  # validate config data\n        write_config(config_path, data)\n        logger.notice(\n            f\"{config_path} generated with \"\n            f\"{preset + ' preset.' if preset else 'custom preset: ' + custom_preset.name if custom_preset else 'defaults.'}\"\n        )\n        config_exists = False\n\n    # check if prompts/ folder already exists else create it\n    if prompts_dir.exists():\n        logger.error(f\"{SNIB_PROMPTS_DIR} already exists at {prompts_dir}\")\n        prompts_dir_exists = True\n    else:\n        prompts_dir.mkdir(exist_ok=True)\n        logger.notice(f\"Output folder created at {prompts_dir}\")\n        prompts_dir_exists = False\n\n    # if something already exists exit\n    if config_exists or prompts_dir_exists:\n        logger.info(\"Use 'snib clean' if you want to initialise the project again.\")\n        raise typer.Exit()\n</code></pre>"},{"location":"reference/pipeline/#snib.pipeline.SnibPipeline.scan","title":"<code>scan(path=Path.cwd(), description=None, task=None, include_raw=None, exclude_raw=None, no_default_exclude=False, smart=False, chunk_size=None, force=False)</code>","text":"<p>Runs the Snib scanning pipeline on the specified project.</p> <p>Steps: - Load the project configuration (<code>snibconfig.toml</code>). - Validate presence of output folder. - Merge CLI filters with configuration filters. - Apply smart include/exclude rules. - Detect conflicts between include and exclude patterns. - Perform the actual scanning and chunking using the <code>Scanner</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Project directory.</p> <code>cwd()</code> <code>description</code> <code>str</code> <p>Optional project description or change summary.</p> <code>None</code> <code>task</code> <code>str</code> <p>Optional task name from available AI instructions.</p> <code>None</code> <code>include_raw</code> <code>str</code> <p>Raw comma-separated include patterns.</p> <code>None</code> <code>exclude_raw</code> <code>str</code> <p>Raw comma-separated exclude patterns.</p> <code>None</code> <code>no_default_exclude</code> <code>bool</code> <p>If True, disables default exclusions.</p> <code>False</code> <code>smart</code> <code>bool</code> <p>Enables smart filtering for code files.</p> <code>False</code> <code>chunk_size</code> <code>int</code> <p>Max number of characters per prompt chunk.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Overwrite existing output files without confirmation.</p> <code>False</code> <p>Raises:</p> Type Description <code>Exit</code> <p>If configuration or output folder is missing.</p> Source code in <code>src/snib/pipeline.py</code> <pre><code>def scan(\n    self,\n    path: Path = Path.cwd(),\n    description: str = None,\n    task: str = None,\n    include_raw: str = None,\n    exclude_raw: str = None,\n    no_default_exclude: bool = False,\n    smart: bool = False,\n    chunk_size: int = None,\n    force: bool = False,\n):\n    \"\"\"\n    Runs the Snib scanning pipeline on the specified project.\n\n    Steps:\n    - Load the project configuration (`snibconfig.toml`).\n    - Validate presence of output folder.\n    - Merge CLI filters with configuration filters.\n    - Apply smart include/exclude rules.\n    - Detect conflicts between include and exclude patterns.\n    - Perform the actual scanning and chunking using the `Scanner`.\n\n    Args:\n        path (Path): Project directory.\n        description (str): Optional project description or change summary.\n        task (str): Optional task name from available AI instructions.\n        include_raw (str): Raw comma-separated include patterns.\n        exclude_raw (str): Raw comma-separated exclude patterns.\n        no_default_exclude (bool): If True, disables default exclusions.\n        smart (bool): Enables smart filtering for code files.\n        chunk_size (int): Max number of characters per prompt chunk.\n        force (bool): Overwrite existing output files without confirmation.\n\n    Raises:\n        typer.Exit: If configuration or output folder is missing.\n    \"\"\"\n\n    config_path = path / SNIB_CONFIG_FILE\n    output_path = path / SNIB_PROMPTS_DIR\n\n    # check if config and output folder exist in path\n    if not config_path.exists():\n        logger.error(f\"Config file '{config_path}' not found\")\n        config_missing = True\n    else:\n        config = load_config(config_path)\n        config = check_config(config)  # validate config\n        config_missing = False\n\n    if not output_path.exists():\n        logger.error(f\"Output directory '{output_path}' not found\")\n        output_missing = True\n    else:\n        output_missing = False\n\n    # if something is missing exit\n    if config_missing or output_missing:\n        logger.info(\"Use 'snib init' first.\")\n        raise typer.Exit()\n\n    # let the user know which config is used (following keys must exist due to check_config)\n    config_name = config[\"config\"][\"name\"]\n    config_author = config[\"config\"][\"author\"]\n    config_version = config[\"config\"][\"version\"]\n\n    logger.info(\n        f\"Using {SNIB_CONFIG_FILE}: {config_name} by {config_author} v{config_version}\"\n    )\n\n    # combine values: CLI &gt; config\n    description = description or config[\"project\"][\"description\"]\n    task = task or config[\"instruction\"][\"task\"]\n\n    # get user includes\n    if include_raw:\n        include_user = [i.strip() for i in include_raw.split(\",\") if i.strip()]\n        logger.debug(f\"User include list: {include_user}\")\n    else:\n        include_user = []\n        logger.debug(\"No user include list specified. (Using 'all')\")\n\n    # get user excludes\n    if exclude_raw:\n        exclude_user = [e.strip() for e in exclude_raw.split(\",\") if e.strip()]\n        logger.debug(f\"User exclude list: {exclude_user}\")\n    else:\n        exclude_user = []\n        logger.debug(\"No user exclude list specified.\")\n\n    include = include_user or config[\"filters\"][\"include\"]\n    exclude = exclude_user or config[\"filters\"][\"exclude\"]\n\n    # add default excludes automatically unless disabled by user\n    no_default_exclude = (\n        no_default_exclude or config[\"filters\"][\"no_default_exclude\"]\n    )\n    if not no_default_exclude:\n        exclude = list(set(exclude + config[\"filters\"][\"default_exclude\"]))\n        logger.debug(f\"Combined exclude: {exclude}\")\n\n    # combine exclude with smart defaults on smart mode enabled\n    smart = smart or config[\"filters\"][\"smart\"]\n    if smart:\n        include = list(set(include + config[\"filters\"][\"smart_include\"]))\n        exclude = list(set(exclude + config[\"filters\"][\"smart_exclude\"]))\n\n    # detect include/exclude conflicts (exclude wins)\n    conflicts, conflicts_log = detect_pattern_conflicts(include, exclude)\n    if conflicts_log:\n        logger.warning(\n            f\"Pattern conflicts detected (Exclude wins): {conflicts_log}\"\n        )\n\n    if conflicts:\n        include = [p for p in include if not any(p in c for c in conflicts)]\n\n    # TODO: this warning currently only works if --exclude \"test\" and --include \"test/file.py\" is used\n    # this should also work for a implicit path in the --include: --exclude \"test\" and --include \"file.py\" if file.py is in test/\n    # see Issue #2\n    problematic = check_include_in_exclude(path, include, exclude)\n    if problematic:\n        logger.warning(\n            f\"The following include patterns are inside excluded folders and will be ignored: {problematic}\"\n        )\n        # logger.debug(f\"include before removing problematic: {include}\")\n        # logger.debug(f\"problematic include: {problematic}\")\n        include = [p for p in include if not any(p in c for c in problematic)]\n\n    logger.debug(f\"Final include (passed to Scanner.scan): {include}\")\n    logger.debug(f\"Final exclude (passed to Scanner.scan): {exclude}\")\n\n    chunk_size = chunk_size or config[\"output\"][\"chunk_size\"]\n    force = force or config[\"output\"][\"force\"]\n\n    scanner = Scanner(path, config)\n    scanner.scan(description, include, exclude, chunk_size, force, task)\n</code></pre>"},{"location":"reference/scanner/","title":"Scanner","text":""},{"location":"reference/scanner/#snib.scanner.Scanner","title":"<code>snib.scanner.Scanner(path, config)</code>","text":"<p>The core scanning engine of Snib.</p> <p>The Scanner traverses a project directory, applies include/exclude filters, builds structured <code>Section</code> objects, and prepares them for formatting and chunking into prompt-ready text.</p> <p>It integrates with: - <code>Formatter</code> (to structure prompt text) - <code>Chunker</code> (to split large outputs into chunks) - <code>Writer</code> (to persist prompt files to disk)</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Root project directory to scan.</p> <code>config</code> <code>dict</code> <p>Parsed configuration dictionary (from <code>snibconfig.toml</code>).</p> <p>Initialize a Scanner instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Project root directory.</p> required <code>config</code> <code>dict</code> <p>Snib configuration dictionary.</p> required Source code in <code>src/snib/scanner.py</code> <pre><code>def __init__(self, path: Path, config: dict):\n    \"\"\"\n    Initialize a Scanner instance.\n\n    Args:\n        path (Path): Project root directory.\n        config (dict): Snib configuration dictionary.\n    \"\"\"\n    self.path = Path(path).resolve()\n    self.config = check_config(config)\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner._calculate_filter_stats","title":"<code>_calculate_filter_stats(files, type_label)</code>","text":"<p>Calculates file statistics for a filter set.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[Path]</code> <p>Files to analyze.</p> required <code>type_label</code> <code>str</code> <p>Either <code>\"included\"</code> or <code>\"excluded\"</code>.</p> required <p>Returns:</p> Name Type Description <code>FilterStats</code> <code>FilterStats</code> <p>Number of files and total size in bytes.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def _calculate_filter_stats(\n    self, files: list[Path], type_label: str\n) -&gt; FilterStats:\n    \"\"\"\n    Calculates file statistics for a filter set.\n\n    Args:\n        files (list[Path]): Files to analyze.\n        type_label (str): Either `\"included\"` or `\"excluded\"`.\n\n    Returns:\n        FilterStats: Number of files and total size in bytes.\n    \"\"\"\n    stats = FilterStats(type=type_label)\n\n    for f in files:\n        if f.is_file():\n            stats.files += 1\n            stats.size += f.stat().st_size\n\n    return stats\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner._collect_sections","title":"<code>_collect_sections(description, include, exclude, force, task)</code>","text":"<p>Collects structured project sections for prompt generation.</p> <p>This includes: - Project description - Task instruction (from config) - Filter summary (include/exclude patterns and stats) - Project tree - Individual file contents (included files only)</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Project description text.</p> required <code>include</code> <code>list[str]</code> <p>Include patterns (globs/prefixes).</p> required <code>exclude</code> <code>list[str]</code> <p>Exclude patterns (globs/prefixes).</p> required <code>task</code> <code>str</code> <p>Task key (looked up in <code>task_dict</code> in config).</p> required <p>Returns:</p> Type Description <code>list[Section]</code> <p>list[Section]: A list of <code>Section</code> objects representing different parts of the project.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def _collect_sections(\n    self, description, include, exclude, force, task\n) -&gt; list[Section]:\n    \"\"\"\n    Collects structured project sections for prompt generation.\n\n    This includes:\n    - Project description\n    - Task instruction (from config)\n    - Filter summary (include/exclude patterns and stats)\n    - Project tree\n    - Individual file contents (included files only)\n\n    Args:\n        description (str): Project description text.\n        include (list[str]): Include patterns (globs/prefixes).\n        exclude (list[str]): Exclude patterns (globs/prefixes).\n        task (str): Task key (looked up in `task_dict` in config).\n\n    Returns:\n        list[Section]: A list of `Section` objects representing\n            different parts of the project.\n    \"\"\"\n    logger.debug(\"Collecting sections\")\n\n    all_files = [f for f in self.path.rglob(\"*\") if f.is_file()]\n    included_files = self._scan_files(self.path, include, exclude)\n    excluded_files = [f for f in all_files if f not in included_files]\n\n    include_stats = self._calculate_filter_stats(included_files, \"included\")\n    exclude_stats = self._calculate_filter_stats(excluded_files, \"excluded\")\n\n    # let the user know what was included/excluded\n    logger.info(\n        f\"Included stats: Files: {include_stats.files}, Size: {format_size(include_stats.size)}\"\n    )\n    logger.info(\n        f\"Excluded stats: Files: {exclude_stats.files}, Size: {format_size(exclude_stats.size)}\"\n    )\n\n    # get warning_include_limit from config if set (no mandatory config entry)\n    warning_include_limit = self.config[\"filters\"].get(\"warning_include_limit\", 100)\n    if include_stats.files &gt; warning_include_limit:\n        logger.warning(\n            f\"Included files exceed {warning_include_limit}. This may lead to large prompts and increased costs.\"\n        )\n        logger.notice(\"Consider refining your include/exclude patterns.\")\n        if not force:\n            confirm = logger.confirm(\"Do you want to proceed?\", default=False)\n            if not confirm:\n                logger.info(\"Aborted.\")\n                raise typer.Exit()\n\n    # get task instruction from config if set (no mandatory config entry)\n    task_dict = self.config[\"instruction\"].get(\"task_dict\", {})\n    instruction = task_dict.get(task, \"\")\n\n    sections: list[Section] = []\n\n    sections.append(Section(type=\"description\", content=description))\n    sections.append(Section(type=\"task\", content=instruction))\n    sections.append(\n        Section(\n            type=\"filters\",\n            include=include,\n            exclude=exclude,\n            include_stats=include_stats,\n            exclude_stats=exclude_stats,\n        )\n    )\n    sections.append(\n        Section(\n            type=\"tree\",\n            content=\"\\n\".join(\n                build_tree(path=self.path, include=include, exclude=exclude)\n            ),\n        )\n    )\n\n    for file_path in included_files:\n        try:\n            content = file_path.read_text(encoding=\"utf-8\")\n            # TODO: handle binary files better\n        except Exception:\n            content = f\"&lt;Could not read {file_path.name}&gt;\\n\"\n        sections.append(\n            Section(\n                type=\"file\", path=file_path.relative_to(self.path), content=content\n            )\n        )\n\n    logger.debug(f\"Collected {len(sections)} sections\")\n\n    return sections\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner._match_patterns","title":"<code>_match_patterns(rel_path, file_name, glob_patterns, prefix_patterns)</code>","text":"<p>Checks whether a relative path or filename matches any patterns.</p> <p>Matching logic: - Glob patterns are matched against filenames and full relative paths. - Prefix patterns are matched against:     * Exact relative path     * Path starting with prefix (e.g. \"src/snib\")     * Exact filename (e.g. \"utils.py\")     * Path parts containing prefix (e.g. <code>__pycache__</code>).</p> <p>Parameters:</p> Name Type Description Default <code>rel_path</code> <code>str</code> <p>Relative path from project root.</p> required <code>file_name</code> <code>str</code> <p>Filename only.</p> required <code>glob_patterns</code> <code>list[str]</code> <p>Patterns with wildcards.</p> required <code>prefix_patterns</code> <code>list[str]</code> <p>Exact path or filename prefixes.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if path matches any pattern, else False.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def _match_patterns(\n    self,\n    rel_path: str,\n    file_name: str,\n    glob_patterns: list[str],\n    prefix_patterns: list[str],\n) -&gt; bool:\n    \"\"\"\n    Checks whether a relative path or filename matches any patterns.\n\n    Matching logic:\n    - Glob patterns are matched against filenames and full relative paths.\n    - Prefix patterns are matched against:\n        * Exact relative path\n        * Path starting with prefix (e.g. \"src/snib\")\n        * Exact filename (e.g. \"utils.py\")\n        * Path parts containing prefix (e.g. `__pycache__`).\n\n    Args:\n        rel_path (str): Relative path from project root.\n        file_name (str): Filename only.\n        glob_patterns (list[str]): Patterns with wildcards.\n        prefix_patterns (list[str]): Exact path or filename prefixes.\n\n    Returns:\n        bool: True if path matches any pattern, else False.\n    \"\"\"\n    # glob check\n    for g in glob_patterns:\n        if fnmatch.fnmatch(file_name, g) or fnmatch.fnmatch(rel_path, g):\n            return True\n\n    # prefix check\n    for p in prefix_patterns:\n        if (\n            rel_path == p\n            or rel_path.startswith(p + \"/\")\n            or file_name == p\n            or f\"/{p}/\"\n            in f\"/{rel_path}/\"  # folders or path parts somewhere in path\n            # or fnmatch.fnmatch(rel_path, p)  # flexible matching works for: utils.py, /src/snib/utils.py, **/utils.py\n        ):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner._scan_files","title":"<code>_scan_files(root, includes=None, excludes=None)</code>","text":"<p>Scans the project directory for files using include/exclude filters.</p> <ul> <li>Uses <code>os.walk</code> for efficient traversal.</li> <li>Excludes whole directories early for speed.</li> <li>Applies both glob and prefix matching.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>Root directory to scan.</p> required <code>includes</code> <code>list[str] | None</code> <p>Include patterns (default: <code>[\"*\"]</code>).</p> <code>None</code> <code>excludes</code> <code>list[str] | None</code> <p>Exclude patterns (default: <code>[]</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: List of included file paths.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def _scan_files(self, root: Path, includes=None, excludes=None) -&gt; list[Path]:\n    \"\"\"\n    Scans the project directory for files using include/exclude filters.\n\n    - Uses `os.walk` for efficient traversal.\n    - Excludes whole directories early for speed.\n    - Applies both glob and prefix matching.\n\n    Args:\n        root (Path): Root directory to scan.\n        includes (list[str] | None): Include patterns (default: `[\"*\"]`).\n        excludes (list[str] | None): Exclude patterns (default: `[]`).\n\n    Returns:\n        list[Path]: List of included file paths.\n    \"\"\"\n    includes = includes or [\"*\"]\n    excludes = excludes or []\n\n    include_globs, include_prefixes = self._split_patterns(includes)\n    exclude_globs, exclude_prefixes = self._split_patterns(excludes)\n\n    results = []\n\n    for dirpath, dirnames, filenames in os.walk(root):\n        rel_dir = Path(dirpath).relative_to(root).as_posix()\n\n        # --- Step 1: exclude whole directories early (Speed!)\n        # going through list and deleting excluded directories from `dirnames`.\n        dirnames[:] = [\n            d\n            for d in dirnames\n            if not self._match_patterns(\n                f\"{rel_dir}/{d}\" if rel_dir != \".\" else d,\n                d,\n                exclude_globs,\n                exclude_prefixes,\n            )\n        ]\n\n        # --- Step 2: Check files\n        for fname in filenames:\n            rel_path = (\n                f\"{rel_dir}/{fname}\" if rel_dir != \".\" else fname\n            )  # relative path from root\n\n            # Exclude check\n            if self._match_patterns(\n                rel_path, fname, exclude_globs, exclude_prefixes\n            ):\n                continue\n\n            # Include check\n            if self._match_patterns(\n                rel_path, fname, include_globs, include_prefixes\n            ):\n                results.append(Path(dirpath) / fname)\n\n    return results\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner._split_patterns","title":"<code>_split_patterns(patterns)</code>","text":"<p>Splits patterns into glob patterns and prefix patterns.</p> <p>Examples:</p> <p>\"*.py\"     -&gt; glob \"src/snib\" -&gt; prefix \"utils.py\" -&gt; prefix (exact filename)</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>list[str]</code> <p>List of pattern strings.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p>tuple[list[str], list[str]]: - globs: Glob-style patterns (with <code>*</code>, <code>?</code>). - prefixes: Exact filenames or directory prefixes.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def _split_patterns(self, patterns: list[str]) -&gt; tuple[list[str], list[str]]:\n    \"\"\"\n    Splits patterns into glob patterns and prefix patterns.\n\n    Examples:\n        \"*.py\"     -&gt; glob\n        \"src/snib\" -&gt; prefix\n        \"utils.py\" -&gt; prefix (exact filename)\n\n    Args:\n        patterns (list[str]): List of pattern strings.\n\n    Returns:\n        tuple[list[str], list[str]]:\n            - globs: Glob-style patterns (with `*`, `?`).\n            - prefixes: Exact filenames or directory prefixes.\n    \"\"\"\n    globs = []\n    prefixes = []\n    for p in patterns:\n        p = str(p).replace(\"\\\\\", \"/\").rstrip(\"/\")  # normalise Windows/Linux\n        if \"*\" in p or \"?\" in p:\n            globs.append(p)\n        else:\n            prefixes.append(p)\n    return globs, prefixes\n</code></pre>"},{"location":"reference/scanner/#snib.scanner.Scanner.scan","title":"<code>scan(description, include, exclude, chunk_size, force, task)</code>","text":"<p>Executes the scanning pipeline.</p> <p>Workflow: 1. Collects project sections (<code>_collect_sections</code>). 2. Formats them into prompt-ready text (<code>Formatter</code>). 3. Splits into chunks (<code>Chunker</code>). 4. Prepends headers for multi-file prompts. 5. Writes results into <code>prompts</code> (<code>Writer</code>).</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>str</code> <p>Project description text.</p> required <code>include</code> <code>list[str]</code> <p>Include patterns.</p> required <code>exclude</code> <code>list[str]</code> <p>Exclude patterns.</p> required <code>chunk_size</code> <code>int</code> <p>Maximum chunk size (characters).</p> required <code>force</code> <code>bool</code> <p>If True, overwrite existing outputs.</p> required <code>task</code> <code>str</code> <p>Task key for instructions.</p> required <p>Returns:</p> Name Type Description <code>None</code> <p>Results are written to disk in <code>prompts</code>.</p> Source code in <code>src/snib/scanner.py</code> <pre><code>def scan(self, description, include, exclude, chunk_size, force, task):\n    \"\"\"\n    Executes the scanning pipeline.\n\n    Workflow:\n    1. Collects project sections (`_collect_sections`).\n    2. Formats them into prompt-ready text (`Formatter`).\n    3. Splits into chunks (`Chunker`).\n    4. Prepends headers for multi-file prompts.\n    5. Writes results into `prompts` (`Writer`).\n\n    Args:\n        description (str): Project description text.\n        include (list[str]): Include patterns.\n        exclude (list[str]): Exclude patterns.\n        chunk_size (int): Maximum chunk size (characters).\n        force (bool): If True, overwrite existing outputs.\n        task (str): Task key for instructions.\n\n    Returns:\n        None: Results are written to disk in `prompts`.\n    \"\"\"\n    logger.info(f\"Scanning {self.path}\")\n\n    sections = self._collect_sections(description, include, exclude, force, task)\n    formatter = Formatter()\n    formatted = formatter.to_prompt_text(sections)\n\n    chunker = Chunker(chunk_size)\n    chunks = chunker.chunk(formatted)\n\n    # leave headspace for header 100 chars in chunker -&gt; self.header_size\n    # insert header on first lines of every chunk\n\n    chunks_with_header = []\n\n    total = len(chunks)\n    for i, chunk in enumerate(chunks, 1):\n        if total &lt;= 1:\n            header = \"\"\n        else:\n            header = (\n                f\"Please do not give output until all prompt files are sent. Prompt file {i}/{total}\\n\"\n                if i == 1\n                else f\"Prompt file {i}/{total}\\n\"\n            )\n\n        # works with empty info section\n        info_texts = formatter.to_prompt_text(\n            [\n                Section(type=\"info\", content=header)\n            ]  # this executes to_prompt_text i times!\n        )\n        if info_texts:\n            chunks_with_header.append(info_texts[0] + chunk)\n        else:\n            chunks_with_header.append(chunk)\n\n        # chunks_with_header.append(formatter.to_prompt_text([Section(type=\"info\", content=header)])[0] + chunk)\n\n    prompts_dir = self.path / SNIB_PROMPTS_DIR\n\n    writer = Writer(prompts_dir)\n    writer.write_chunks(chunks_with_header, force=force)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#snib.utils.detect_pattern_conflicts","title":"<code>snib.utils.detect_pattern_conflicts(includes, excludes)</code>","text":"<p>Detect conflicts between include and exclude patterns.</p> <p>Cases: - Exact match (include == exclude). - Include pattern matched by exclude. - Exclude pattern more specific than include.</p> <p>Parameters:</p> Name Type Description Default <code>includes</code> <code>list[str]</code> <p>List of include patterns.</p> required <code>excludes</code> <code>list[str]</code> <p>List of exclude patterns.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>set[str]: Conflicting include patterns with explanations.</p> Source code in <code>src/snib/utils.py</code> <pre><code>def detect_pattern_conflicts(includes: list[str], excludes: list[str]) -&gt; set[str]:\n    \"\"\"\n    Detect conflicts between include and exclude patterns.\n\n    Cases:\n    - Exact match (include == exclude).\n    - Include pattern matched by exclude.\n    - Exclude pattern more specific than include.\n\n    Args:\n        includes (list[str]): List of include patterns.\n        excludes (list[str]): List of exclude patterns.\n\n    Returns:\n        set[str]: Conflicting include patterns with explanations.\n    \"\"\"\n\n    conflicts = set()\n    conflicts_log = set()\n    # check each include against each exclude\n    for inc in includes:\n        for exc in excludes:\n            # exact match is a conflict\n            if inc == exc:\n                conflicts.add(inc)\n                conflicts_log.add(f\"{inc} == {exc}\")\n            # include eaten by exclude -&gt; fnmatch.fnmatch(\"*.py\", \"utils.py\") -&gt; False\n            elif fnmatch.fnmatch(inc, exc):\n                conflicts.add(inc)\n                conflicts_log.add(f\"{inc} (matched by {exc})\")\n            # exclude is more specific than include -&gt; fnmatch.fnmatch(\"utils.py\", \"*.py\") -&gt; True DONT ADD TO CONFLICTS!\n            elif fnmatch.fnmatch(exc, inc):\n                conflicts_log.add(f\"{inc} (conflicts with {exc})\")\n\n    return conflicts, conflicts_log\n</code></pre>"},{"location":"reference/utils/#snib.utils.check_include_in_exclude","title":"<code>snib.utils.check_include_in_exclude(path, includes, excludes)</code>","text":"<p>Check whether include patterns fall inside excluded directories.</p> For example <p>includes = [\"src/main.py\"] excludes = [\"src\"] \u2192 \"src/main.py\" is problematic.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Root directory of the project.</p> required <code>includes</code> <code>list[str]</code> <p>Include patterns (file paths).</p> required <code>excludes</code> <code>list[str]</code> <p>Exclude patterns (dir paths).</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of problematic include patterns.</p> Source code in <code>src/snib/utils.py</code> <pre><code>def check_include_in_exclude(\n    path: Path, includes: list[str], excludes: list[str]\n) -&gt; list[str]:\n    \"\"\"\n    Check whether include patterns fall inside excluded directories.\n\n    For example:\n        includes = [\"src/main.py\"]\n        excludes = [\"src\"]\n        \u2192 \"src/main.py\" is problematic.\n\n    Args:\n        path (Path): Root directory of the project.\n        includes (list[str]): Include patterns (file paths).\n        excludes (list[str]): Exclude patterns (dir paths).\n\n    Returns:\n        list[str]: List of problematic include patterns.\n    \"\"\"\n    problematic = []\n\n    for inc in includes:\n        inc_path = path / inc\n        if not inc_path.exists():\n            continue\n        for exc in excludes:\n            exc_path = path / exc\n            # only check folders\n            if exc_path.is_dir() and exc_path in inc_path.parents:\n                problematic.append(inc)\n    return problematic\n</code></pre>"},{"location":"reference/utils/#snib.utils.build_tree","title":"<code>snib.utils.build_tree(path, include, exclude, prefix='')</code>","text":"<p>Build a visual tree representation of a project directory.</p> <p>Filtering rules: - Excluded entries are never shown. - Files are shown if they match include patterns (or if include is empty). - Directories are shown if:     * They are explicitly included, or     * They contain at least one valid file inside.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Root directory to scan.</p> required <code>include</code> <code>list[str]</code> <p>Include patterns (globs, filenames, or dirs).</p> required <code>exclude</code> <code>list[str]</code> <p>Exclude patterns (globs, filenames, or dirs).</p> required <code>prefix</code> <code>str</code> <p>Current tree indentation prefix. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of formatted strings representing the directory tree.</p> Source code in <code>src/snib/utils.py</code> <pre><code>def build_tree(\n    path: Path, include: list[str], exclude: list[str], prefix: str = \"\"\n) -&gt; list[str]:\n    \"\"\"\n    Build a visual tree representation of a project directory.\n\n    Filtering rules:\n    - Excluded entries are never shown.\n    - Files are shown if they match include patterns (or if include is empty).\n    - Directories are shown if:\n        * They are explicitly included, or\n        * They contain at least one valid file inside.\n\n    Args:\n        path (Path): Root directory to scan.\n        include (list[str]): Include patterns (globs, filenames, or dirs).\n        exclude (list[str]): Exclude patterns (globs, filenames, or dirs).\n        prefix (str, optional): Current tree indentation prefix. Defaults to \"\".\n\n    Returns:\n        list[str]: List of formatted strings representing the directory tree.\n    \"\"\"\n    ELBOW = \"\u2514\u2500\u2500\"\n    TEE = \"\u251c\u2500\u2500\"\n    PIPE_PREFIX = \"\u2502   \"\n    SPACE_PREFIX = \"    \"\n\n    def should_include_file(entry: Path) -&gt; bool:\n        # excluded?\n        if any(entry.match(p) or entry.name == p for p in exclude):\n            return False\n\n        # only files, if include empty or match\n        if entry.is_file():\n            return not include or any(\n                entry.match(p) or entry.name == p or p in entry.parts for p in include\n            )\n\n        # folder: show if\n        #    - include emptry or\n        #    - foldername itself in or\n        #    - any file below matches include\n        if entry.is_dir():\n            if not include or entry.name in include:\n                return True\n            # min. one file below matches include\n            return any(\n                f.match(p) or f.name == p\n                for p in include\n                for f in entry.rglob(\"*\")\n                if f.is_file()\n            )\n\n        return True\n\n    lines = [path.name] if not prefix else []\n    entries = [\n        e\n        for e in sorted(path.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))\n        if should_include_file(e)\n    ]\n\n    for i, entry in enumerate(entries):\n        connector = ELBOW if i == len(entries) - 1 else TEE\n        line = f\"{prefix}{connector} {entry.name}\"\n\n        if entry.is_dir():\n            extension = SPACE_PREFIX if i == len(entries) - 1 else PIPE_PREFIX\n            subtree = build_tree(entry, include, exclude, prefix + extension)\n            if len(subtree) &gt; 0:  # only append if not empty\n                lines.append(line)\n                lines.extend(subtree)\n        else:\n            lines.append(line)\n\n    return lines\n</code></pre>"},{"location":"reference/utils/#snib.utils.format_size","title":"<code>snib.utils.format_size(size)</code>","text":"<p>Convert a byte size into a human-readable string.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>File size in bytes.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable string (B, KB, MB).</p> Source code in <code>src/snib/utils.py</code> <pre><code>def format_size(size: int) -&gt; str:\n    \"\"\"\n    Convert a byte size into a human-readable string.\n\n    Args:\n        size (int): File size in bytes.\n\n    Returns:\n        str: Human-readable string (B, KB, MB).\n    \"\"\"\n    # TODO: add GB\n    if size &gt;= 1024**2:\n        return f\"{size / (1024**2):.2f} MB\"\n    elif size &gt;= 1024:\n        return f\"{size / 1024:.2f} KB\"\n    return f\"{size} B\"\n</code></pre>"},{"location":"reference/utils/#snib.utils.get_task_choices","title":"<code>snib.utils.get_task_choices()</code>","text":"<p>Retrieve available task keys from config.</p> <ul> <li>Reads tasks from <code>snibconfig.toml</code> if available.</li> <li>Falls back to default config otherwise.</li> </ul> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Available task keys (for CLI autocompletion).</p> Source code in <code>src/snib/utils.py</code> <pre><code>def get_task_choices() -&gt; list[str]:\n    \"\"\"\n    Retrieve available task keys from config.\n\n    - Reads tasks from `snibconfig.toml` if available.\n    - Falls back to default config otherwise.\n\n    Returns:\n        list[str]: Available task keys (for CLI autocompletion).\n    \"\"\"\n    config = load_config()\n    # TODO: validate config here!!!\n    if not config:\n        config = SNIB_DEFAULT_CONFIG\n    task_dict = config.get(\"instruction\", {}).get(\"task_dict\", {})\n    return Choice(list(task_dict.keys()))\n</code></pre>"},{"location":"reference/utils/#snib.utils.get_preset_choices","title":"<code>snib.utils.get_preset_choices()</code>","text":"<p>Retrieve available preset names.</p> <ul> <li>Scans the <code>snib.presets</code> package for <code>.toml</code> files.</li> <li>Strips file extensions.</li> </ul> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Preset names without extension (for CLI autocompletion).</p> Source code in <code>src/snib/utils.py</code> <pre><code>def get_preset_choices() -&gt; list[str]:\n    \"\"\"\n    Retrieve available preset names.\n\n    - Scans the `snib.presets` package for `.toml` files.\n    - Strips file extensions.\n\n    Returns:\n        list[str]: Preset names without extension (for CLI autocompletion).\n    \"\"\"\n    try:\n        files = resources.files(presets).iterdir()\n        return Choice(\n            [f.name.rsplit(\".\", 1)[0] for f in files if f.name.endswith(\".toml\")]\n        )\n    except FileNotFoundError:\n        # if package is not installed right\n        return []\n</code></pre>"},{"location":"reference/writer/","title":"Writer","text":""},{"location":"reference/writer/#snib.writer.Writer","title":"<code>snib.writer.Writer(output_dir)</code>","text":"<p>Handles writing prompt chunks to disk and managing output files.</p> <p>This class is responsible for: - Ensuring the output directory exists. - Writing prompt chunks into sequentially numbered <code>.txt</code> files. - Optionally clearing existing prompt files before writing.</p> <p>Initialize a Writer.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Path to the output directory where prompt files should be stored. The directory is created if it does not exist.</p> required Source code in <code>src/snib/writer.py</code> <pre><code>def __init__(self, output_dir: str):\n    \"\"\"\n    Initialize a Writer.\n\n    Args:\n        output_dir (str): Path to the output directory where prompt files\n            should be stored. The directory is created if it does not exist.\n    \"\"\"\n    # TODO: fix this section\n    self.output_dir = Path(output_dir)\n    self.output_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/writer/#snib.writer.Writer.clear_output","title":"<code>clear_output()</code>","text":"<p>Delete all existing prompt files (<code>prompt_*.txt</code>) in the output directory.</p> <ul> <li>This is typically called before writing new chunks.</li> <li>Only files matching the pattern <code>prompt_*.txt</code> are removed.</li> </ul> Source code in <code>src/snib/writer.py</code> <pre><code>def clear_output(self):\n    \"\"\"\n    Delete all existing prompt files (`prompt_*.txt`) in the output directory.\n\n    - This is typically called before writing new chunks.\n    - Only files matching the pattern `prompt_*.txt` are removed.\n    \"\"\"\n    for file_path in self.output_dir.glob(\"prompt_*.txt\"):\n        if file_path.is_file():\n            file_path.unlink()\n</code></pre>"},{"location":"reference/writer/#snib.writer.Writer.write_chunks","title":"<code>write_chunks(chunks, force=False)</code>","text":"<p>Write prompt chunks to text files.</p> <p>Behavior: - Existing files named <code>prompt_*.txt</code> are cleared if <code>force=True</code>. - If <code>force=False</code> and prompt files already exist, the user is asked   for confirmation before overwriting. - Files are written as <code>prompt_1.txt</code>, <code>prompt_2.txt</code>, etc. - Each file contains one chunk of text.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>list[str]</code> <p>List of text chunks to be written.</p> required <code>force</code> <code>bool</code> <p>Overwrite existing files without confirmation. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: List of paths to the written text files.</p> <p>Raises:</p> Type Description <code>Exit</code> <p>If the user aborts when prompted for confirmation.</p> Source code in <code>src/snib/writer.py</code> <pre><code>def write_chunks(self, chunks: list[str], force: bool = False) -&gt; list[Path]:\n    \"\"\"\n    Write prompt chunks to text files.\n\n    Behavior:\n    - Existing files named `prompt_*.txt` are cleared if `force=True`.\n    - If `force=False` and prompt files already exist, the user is asked\n      for confirmation before overwriting.\n    - Files are written as `prompt_1.txt`, `prompt_2.txt`, etc.\n    - Each file contains one chunk of text.\n\n    Args:\n        chunks (list[str]): List of text chunks to be written.\n        force (bool, optional): Overwrite existing files without confirmation.\n            Defaults to False.\n\n    Returns:\n        list[Path]: List of paths to the written text files.\n\n    Raises:\n        typer.Exit: If the user aborts when prompted for confirmation.\n    \"\"\"\n\n    logger.debug(f\"Begin writing {len(chunks)} chunk(s) to {self.output_dir}\")\n\n    # Clear existing prompt files if needed\n    prompt_files = list(self.output_dir.glob(\"prompt_*.txt\"))\n    if prompt_files:\n        count = len(prompt_files)\n        if force:\n            self.clear_output()\n            logger.notice(\n                f\"Cleared {count} existing prompt file(s) in '{self.output_dir}'.\"\n            )\n        else:\n            confirm = logger.confirm(\n                f\"'{self.output_dir}' already contains {count} prompt file(s). Clear them?\",\n                default=False,\n            )\n            if not confirm:\n                logger.info(\"Aborted.\")\n                raise typer.Exit()\n\n            self.clear_output()\n            logger.notice(\n                f\"Cleared {count} existing prompt file(s) in '{self.output_dir}'.\"\n            )\n\n    txt_files = []\n\n    total_size = sum(len(c.encode(\"utf-8\")) for c in chunks)\n    size_str = format_size(total_size)\n\n    # Ask before writing\n    if not force:\n        confirm = logger.confirm(\n            f\"Do you want to write {len(chunks)} prompt file(s) (total size {size_str}) to '{self.output_dir}'?\",\n            default=False,\n        )\n        if not confirm:\n            logger.info(\"Aborted.\")\n            raise typer.Exit()\n\n    for i, chunk in enumerate(chunks, 1):\n        filename = self.output_dir / f\"prompt_{i}.txt\"\n        filename.write_text(chunk, encoding=\"utf-8\")\n        txt_files.append(filename)\n\n    logger.notice(f\"Wrote {len(txt_files)} text file(s) to {self.output_dir}\")\n    return txt_files\n</code></pre>"},{"location":"usage/cli/","title":"CLI Usage","text":"<pre><code>snib [OPTIONS] COMMAND [ARGS]...\n</code></pre>"},{"location":"usage/cli/#global-options","title":"Global Options","text":"Option Description <code>--verbose / --no-verbose</code> Show INFO logs (default: <code>--no-verbose</code>) <code>--install-completion</code> Install shell completion <code>--show-completion</code> Show completion script <code>--help</code> Show this message and exit"},{"location":"usage/cli/#commands","title":"Commands","text":"<p><code>init</code></p> <p>Generates a new <code>prompts</code> folder and <code>snibconfig.toml</code> in your project directory.</p> Option Short Description <code>--path PATH</code> <code>-p</code> Target directory (default: current directory) <code>--preset</code> Preset to use: <code>unity</code>, <code>unreal</code> (extendable) <code>--help</code> Show this message and exit <p><code>scan</code></p> <p>Scans your project and generates prompt-ready chunks.</p> Option Short Description <code>--path PATH</code> <code>-p</code> Path to scan (default: current directory) <code>--description TEXT</code> <code>-d</code> Short project description or changes you want to make <code>--task</code> <code>-t</code> Predefined task: <code>debug</code>, <code>comment</code>, <code>refactor</code>, <code>optimize</code>, <code>summarize</code>, <code>document</code>, <code>test</code>, <code>analyze</code> <code>--include TEXT</code> <code>-i</code> File types or folders to include, e.g., <code>*.py, cli.py</code> <code>--exclude TEXT</code> <code>-e</code> File types or folders to exclude, e.g., <code>*.pyc, __pycache__</code> <code>--no-default-excludes</code> <code>-E</code> Disable automatic exclusion of <code>venv</code>, <code>promptready</code>, <code>__pycache__</code> <code>--smart</code> <code>-s</code> Smart mode: only code files, ignores logs/large files <code>--chunk-size INT</code> <code>-c</code> Max characters per chunk (default: 30,000) <code>--force</code> <code>-f</code> Force overwrite existing prompt files <code>--help</code> Show this message and exit <p><code>clean</code></p> <p>Removes the <code>prompts</code> folder and/or <code>sinibconfig.toml</code> from your project directory.</p> Option Short Description <code>--path PATH</code> <code>-p</code> Project directory (default: current directory) <code>--force</code> <code>-f</code> Do not ask for confirmation <code>--config-only</code> Only delete <code>snibconfig.toml</code> <code>--output-only</code> Only delete the <code>promptready</code> folder <code>--help</code> Show this message and exit"},{"location":"usage/configuration/","title":"Configuration","text":"<p>Content coming soon.</p>"},{"location":"usage/filters/","title":"Filters","text":"<p>Content coming soon.</p>"},{"location":"usage/getting-started/","title":"Getting Started","text":""},{"location":"usage/getting-started/#installation","title":"Installation","text":"<pre><code>pip install snib\n</code></pre> <p>Alternatively download the latest wheel here: Latest Release</p> <p>Recommended Setup</p> <ol> <li> <p>Navigate to your project folder:</p> <pre><code>cd /path/to/your/project\n</code></pre> </li> <li> <p>Create a Python virtual environment in your project folder:</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <ul> <li>Linux/macOS:</li> </ul> <pre><code>source venv/bin/activate\n</code></pre> <ul> <li>Windows CMD:</li> </ul> <pre><code>venv\\Scripts\\activate\n</code></pre> </li> <li> <p>Install snib as shown above.</p> </li> </ol>"},{"location":"usage/getting-started/#running-snib","title":"Running Snib","text":"<p>After setting up a virtual environment and installing snib, you can run commands directly inside your project folder. Start by initializing your project:</p> <p><pre><code>snib init\n</code></pre> This generates the default config and output folder:</p> <p>Initialisation succesfull</p> <p>[NOTE] /path/to/your/project/snibconfig.toml generated with defaults</p> <p>[NOTE] Output folder created at /path/to/your/project/prompts</p> <p>Now scan your project. For small to medium projects, <code>--smart</code> is usually enough:</p> <pre><code>snib scan --smart\n</code></pre> <p>On medium-sized projects you may see a warning like this:</p> <p>Too many files included</p> <p>[WARN] Included files exceed 100. This may lead to large prompts and higher costs.</p> <p>In such cases, review your include/exclude rules. A good starting point is to check your project directory for files or folders that don\u2019t need to be processed.</p> <p>For example, if you have a folder called junk that also contains source code, the <code>--smart</code> option includes it by default. You should explicitly exclude it using the <code>--exclude</code> option:</p> <pre><code>snib scan --smart --exclude \"junk\"\n</code></pre> <p>Large or complex projects</p> <p>Keep your scans lean by excluding irrelevant files. Use <code>--exclude</code> / <code>--include</code> patterns or edit <code>snibconfig.toml</code>. Presets can also help for common project types (see Presets).</p> <p>If you try to include and exclude the same pattern, snib detects a pattern conflict:</p> <pre><code>snib scan --smart --exclude \"junk\" --include \"junk\"\n</code></pre> <p>Pattern conflicts</p> <p>[WARN] Pattern conflicts detected (Exclude wins): {'junk'}</p> <p>Snib resolves such conflicts by always letting the exclude win. This makes it possible to combine broad includes with specific excludes:</p> <pre><code>snib scan --smart --exclude \"test.py\"\n</code></pre> <p>Pattern conflicts</p> <p>[WARN] Pattern conflicts detected (Exclude wins): {'*.py (conflicts with test.py)'}</p> <p>Here <code>--smart</code> includes all <code>*.py</code> files, but the explicit exclude removes <code>test.py</code>. Thanks to the exclude wins rule, all Python files are included except <code>test.py</code>.</p> <p>You can also guide the AI with a description and a task (see Tasks):</p> <pre><code>snib scan --smart --description \"I want to change ...\" --task refactor\n</code></pre> <p>After scanning, snib creates prompt files (<code>prompt_1.txt</code>, \u2026) in the <code>prompts</code> folder.</p> Show Prompt Example <p> <pre><code>#[INFO]\nPlease do not give output until all prompt files are sent. Prompt file 1/4\n\n#[DESCRIPTION]\nI want to change ...\n\n#[TASK]\nRefactor: Suggest refactorings to make the code cleaner, more readable, and maintainable.\n\n#[INCLUDE/EXCLUDE]\nInclude patterns: ['*.py']\nExclude patterns: ['venv', 'prompts', ..., 'snibconfig.toml']\nIncluded files: files: 34, total size: 92.79 KB\nExcluded files: files: 20181, total size: 339.37 MB\n\n#[PROJECT TREE]\nsnib\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 snib\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 __main__.py\n\u2502       \u251c\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 writer.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 test_chunker.py\n    \u251c\u2500\u2500 ...\n    \u2514\u2500\u2500 test_writer.py\n\n#[FILE] tests\\test_chunker.py\nimport pytest\nfrom snib.chunker import Chunker\n\n...\n\n#[INFO]\nPrompt file 4/4\n\n...\n</code></pre> <p></p> <p>For large models you might want to increase the chunk size:</p> <pre><code>snib scan --smart --description \"...\" --task refactor --chunk-size 100000\n</code></pre> <p>Choosing the right chunk size</p> <p>See the Chunk Size Table below.</p> <p>To reset everything (e.g. broken config), run:</p> <pre><code>snib clean \n</code></pre> <p>Running outside the project path</p> <p>If you don\u2019t run snib from your project folder, use the <code>--path</code> option with every command (<code>init</code>, <code>scan</code>, <code>clean</code>).</p>"},{"location":"usage/getting-started/#chunk-size","title":"Chunk Size","text":"Model / LLM Max Context (Tokens) Recommended <code>--chunk-size</code> (Chars) Notes LLaMA 2 (7B/13B) 4,000 12,000 \u2013 14,000 1 token \u2248 3\u20134 chars Mistral 7B 8,000 28,000 Leave a safety margin GPT-4 classic 8,000 28,000 GPT-4-32k 32,000 110,000 GPT-4o / GPT-5 (128k) 128,000 450,000 \u2013 500,000 Very large models, massive chunks possible <p>Rule of Thumb</p> <p>These are rough estimates to guide you when setting <code>--chunk-size</code>. Snib chunks by characters, not tokens, so chunk sizes vary by model. Always adjust based on your model's context limit and safety margin.</p>"},{"location":"usage/getting-started/#advanced","title":"Advanced","text":"<ul> <li><code>--no-default-excludes</code>: Don\u2019t exclude venv, prompts, or snibconfig.toml.</li> <li><code>--force</code>: Runs commands without confirmation.</li> </ul> <p>Use with caution</p> <p>The <code>--force</code> option can overwrite existing files or create unwanted text files if your include/exclude rules are not set correctly.</p> <p>Commands and Options</p> <p>For a list of all commands and options take a look at CLI Usage.</p>"},{"location":"usage/presets/","title":"Presets","text":"<p>Presets are predefined <code>.toml</code> configuration files that simplify using snib across different project types (Python, Web, C++, Unity, etc.). They\u2019re optional - without a preset, snib falls back to the default configuration.</p> <p>Why use presets</p> <p>Presets save you time and provide a solid starting point. They also help maintain consistency across projects.</p>"},{"location":"usage/presets/#structure","title":"Structure","text":"<p>Each preset follows the same structure as the default <code>snibconfig.toml</code>:</p> Show Default Config <p> <p><pre><code>[config]\ndescription = \"Preset description\"\nauthor = \"author\"\nversion = \"1.0\"\n\n[project]\npath = \".\"\ndescription = \"\"\n\n[instruction]\ntask = \"\"\n\n[filters]\ninclude = []\nexclude = []\nsmart_include = []\nsmart_exclude = []\ndefault_exclude = []\nno_default_exclude = false\nsmart = false\n\n[output]\nchunk_size = 30000\nforce = false\n\n[instruction.task_dict]\ndebug = \"Debug: ...\"\ncomment = \"Comment: ...\"\nrefactor = \"Refactor: ...\"\noptimize = \"Optimize: ...\"\nsummarize = \"Summarize: ...\"\ndocument = \"Document: ...\"\ntest = \"Test: ...\"\nanalyze = \"Analyze: ...\"\n</code></pre> </p>"},{"location":"usage/presets/#available-presets","title":"Available Presets","text":"<p>Included: <code>cpp</code>, <code>datascience</code>, <code>java</code>, <code>python</code>, <code>unity</code>, <code>unreal</code>, <code>web</code> (.toml)  </p> <p>Why is there only so little</p> <p>These serve as starting points and can be adjusted or extended by the community.</p>"},{"location":"usage/presets/#creating-your-own-preset","title":"Creating Your Own Preset","text":"<p>Quick Start</p> <ol> <li>Copy an existing preset (e.g., <code>python.toml</code>).</li> <li>Adjust the <code>[filters]</code> section (include, exclude) to match your project.</li> <li>Update the <code>[config]</code> section.</li> <li>Test your preset locally.</li> </ol> <pre><code>snib init --preset-custom \"custom.toml\"\nsnib scan\n</code></pre> <p>If you\u2019d like to support the community, feel free to contribute your own presets. See Contributing.</p>"},{"location":"usage/tasks/","title":"Tasks","text":"<p>Content coming soon.</p>"}]}