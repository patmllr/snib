#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/2

#[INCLUDE/EXCLUDE]
Include patterns: 
Exclude patterns: ['dist', 'venv', '.git', '__pycache__', 'junk', 'snibconfig.toml', 'promptready']
Included files: files: 22, total size: 44.43 KB
Excluded files: files: 2398, total size: 266.56 MB

#[PROJECT TREE]
snib
├── src
│   └── snib
│       ├── presets
│       │   ├── unity.toml
│       │   └── unreal.toml
│       ├── __init__.py
│       ├── __main__.py
│       ├── chunker.py
│       ├── cli.py
│       ├── config.py
│       ├── formatter.py
│       ├── models.py
│       ├── scanner.py
│       ├── utils.py
│       └── writer.py
├── tests
│   ├── test_chunker.py
│   ├── test_cli_scan.py
│   ├── test_formatter.py
│   ├── test_scanner.py
│   ├── test_utils.py
│   └── test_writer.py
├── .gitignore
├── LICENSE
├── pyproject.toml
└── README.md

#[FILE] .gitignore
# Python
__pycache__/
*.py[cod]
*.so
*.egg
*.egg-info/
dist/
build/

# Virtual environments
venv/
.env/
.venv/

# IDE / Editor configs
.vscode/
.idea/

# OS junk
.DS_Store
Thumbs.db

# Logs
*.log

# Project-specific junk
junk/

#[FILE] LICENSE
MIT License

Copyright (c) 2025 Patrick Müller

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


#[FILE] pyproject.toml
[build-system]
requires = ["hatchling >= 1.26"]
build-backend = "hatchling.build"

[project]
name = "snib"
version = "0.2.1"
authors = [
  { name="Patrick Müller", email="patrick.mueller.net@protonmail.com" },
]
description = "snib scans projects and generates prompt-ready chunks"
readme = "README.md"
requires-python = ">=3.9"
classifiers = [
    "Programming Language :: Python :: 3.9",
    "Operating System :: OS Independent",
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Code Generators",
]
license = "MIT"
license-files = ["LICEN[CS]E*"]

[project.urls]
Homepage = "https://github.com/patmllr/snib"
Issues = "https://github.com/patmllr/snib/issues"

[project.scripts]
snib = "snib.__main__:app"

[project.dependencies]
typer = { extras = ["all"], version = ">=0.9.0" }

[tool.hatch.build.targets.wheel]
include = [
    "snib/presets/*.toml"
]

#[FILE] README.md
# Snib ✂️

**Snib** is a CLI Python tool to scan projects, collect source files, and generate **prompt-ready chunks** for use with large language models (LLMs). It supports filtering by file types, folders, regex and can optionally run in **smart mode** to automatically ignore large logs or binary files.

## 🚀 Features 

- Scan entire projects recursively.
- Include or exclude files/folders with globs or explicit paths.
- Generate prompt-ready chunks with configurable size.
- Built-in tasks: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze`.
- Smart mode automatically focuses on source code and ignores unnecessary files.
- Detects conflicts between include/exclude patterns.
- Logs scanning and processing details at INFO or DEBUG level.
- Clean and organized prompt output for large projects.

---

## 📦 Installation 

```bash
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.2.1-py3-none-any.whl
```

Alternatively download the latest wheel here: [Latest Release](https://github.com/patmllr/snib/releases/latest)

### 🧰 Recommended setup

Create a Python virtual environment inside your project folder and install `snib` in the `venv`:

```bash
python -m venv venv
source venv/Scripts/activate   # Windows Git Bash
source venv/bin/activate       # Linux / macOS
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.2.1-py3-none-any.whl
```

## ⚡ Usage

```bash
snib --path ./my_project \
     --description "This is a demo." \
     --include "*.py, test.js, src/test" \
     --exclude "*.log, *.tmp" \
     --chunk-size 10000 \
     --output promptready \
     --task debug \
     --smart \
     --verbose
```

### ⚙️ Options

| Option                  | Short | Description                                                                                             |
| ----------------------- | ----- | ------------------------------------------------------------------------------------------------------- |
| `--path`                | `-p`  | Path to scan (default: current directory)                                                               |
| `--description`         | `-d`  | Short description of the project/changes                                                                |
| `--include`             | `-i`  | File types or folders to include, e.g., `*.py, cli.py`                                                  |
| `--exclude`             | `-e`  | File types or folders to exclude, e.g., `*.pyc, __pycache__`                                            |
| `--chunk-size`          | `-c`  | Max characters per chunk (default: 30,000)                                                              |
| `--output`              | `-o`  | Folder to save prompt-ready chunks (default: `promptready`)                                             |
| `--force`               | `-f`  | Force overwrite existing prompt files                                                                   |
| `--task`                | `-t`  | Predefined task: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze` |
| `--verbose`             | `-V`  | Show INFO logs                                                                                          |
| `--dev`                 | `-D`  | Show DEBUG logs                                                                                         |
| `--smart`               | `-s`  | Smart mode: includes only code files, ignores large/log files                                           |
| `--no-default-excludes` | `-E`  | Disable automatic exclusion of `venv`, `promptready`, `__pycache__`                                     |

## 👍 Rule of Thumb for Chunk Sizes

Since snib chunks by characters, the following guidelines can help to estimate the chunk size:

| Model / LLM           | Max Context (Tokens) | Recommended `--chunk-size` (Chars) | Notes                                      |
| --------------------- | -------------------- | ---------------------------------- | ------------------------------------------ |
| LLaMA 2 (7B/13B)      | 4,000                | 12,000 – 14,000                    | 1 token ≈ 3–4 chars                        |
| Mistral 7B            | 8,000                | 28,000                             | Leave a safety margin                      |
| GPT-4 classic         | 8,000                | 28,000                             |                                            |
| GPT-4-32k             | 32,000               | 110,000                            |                                            |
| GPT-4o / GPT-5 (128k) | 128,000              | 450,000 – 500,000                  | Very large models, massive chunks possible |

## 🗂️ Example Project Scan

```text
#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/4

#[DESCRIPTION]
This is a demo.

#[TASK]
Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.

#[INCLUDE/EXCLUDE]
Include patterns: ['*.py']
Exclude patterns: ['promptready', 'dist', 'junk', 'venv', '__pycache__']
Included files: files: 16, total size: 28.86 KB
Excluded files: files: 1943, total size: 262.11 MB

#[PROJECT TREE]
snib
├── src
│   └── snib
│       ├── __init__.py
│       ├── __main__.py
│       ├── chunker.py
│       ├── cli.py
│       ├── constants.py
│       ├── formatter.py
│       ├── models.py
│       ├── scanner.py
│       ├── utils.py
│       └── writer.py
└── tests
    ├── test_chunker.py
    ├── test_cli_scan.py
    ├── test_formatter.py
    ├── test_scanner.py
    ├── test_utils.py
    └── test_writer.py

#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

...

#[INFO]
Prompt file 4/4

        for file_path in self.output_dir.glob("prompt_*.txt"):
            if file_path.is_file():
                file_path.unlink()
        logger.info(f"Cleared existing prompt file(s) in {self.output_dir}")


#[FILE] src\snib\__init__.py


#[FILE] src\snib\__main__.py
from .cli import main

if __name__ == "__main__":
    main()
```

After running snib, a `promptready` folder is generated with prompt files ready to get copied to the clipboard:

```text
prompt_1.txt
...
promt_4.txt
```

## 🧠 Best Practices

- Always install snib inside a virtual environment.
- `venv` and `promptready` are automatically excluded from scans.
- Use `--smart` to focus on code and avoid unnecessary large files.
- Adjust `--chunk-size` based on your target LLM and the table above.
- If followed these instructions just exclude some folders you don't need to be scanned and run snib on your project like:

```bash
snib -e "dist, junk" --chunk-size 100000 --smart --verbose
```

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/your-feature`
3. Commit your changes: `git commit -m "Add new feature"`
4. Push to branch: `git push origin feature/your-feature`
5. Open a Pull Request

## 📝 Notes

- Snib is designed to be lightweight and easily integrated into CI/CD pipelines.
- Works cross-platform (Windows, Linux, macOS).
- Automatically inserts headers in multi-chunk outputs to guide LLM processing.

## 📜 License

MIT License © 2025 Patrick Müller

#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

def test_chunker_splits_correctly():
    chunker = Chunker(chunk_size=50)
    sections = ["line1\nline2\nline3", "line4\nline5"]
    chunks = chunker.chunk(sections)
    
    for c in chunks:
        assert len(c) + chunker.header_size <= chunker.chunk_size
    assert "".join(chunks) == "line1\nline2\nline3line4\nline5"

def test_chunker_empty_input():
    chunker = Chunker(chunk_size=50)
    chunks = chunker.chunk([])
    assert chunks == []


#[FILE] tests\test_cli_scan.py
import pytest
from pathlib import Path
from snib.scanner import Scanner
from snib.formatter import Formatter
from snib.chunker import Chunker
from snib.writer import Writer
from snib.models import Section

def test_end_to_end_scan(tmp_path):
    # -------------------------------
    # Setup fake project files
    # -------------------------------
    # Create folders and files
    (tmp_path / "src").mkdir()
    (tmp_path / "src" / "file1.py").write_text("print('hello')")
    (tmp_path / "src" / "file2.js").write_text("console.log('hi')")
    (tmp_path / "README.md").write_text("# Project README")
    (tmp_path / "ignore.log").write_text("This should be ignored")

    # -------------------------------
    # Initialize Scanner
    # -------------------------------
    scanner = Scanner(tmp_path)

    include_patterns = ["*.py", "*.js"]
    exclude_patterns = ["*.log"]

    sections = scanner._collect_sections(
        description="Test project",
        include=include_patterns,
        exclude=exclude_patterns,
        task="test"
    )

    # Check sections collected
    section_types = [s.type for s in sections]
    assert "description" in section_types
    assert "task" in section_types
    assert "filters" in section_types
    assert "tree" in section_types
    assert any(s.type == "file" for s in sections)

    # -------------------------------
    # Formatter
    # -------------------------------
    formatter = Formatter()
    formatted_texts = formatter.to_prompt_text(sections)
    combined_text = "\n".join(formatted_texts)
    assert "Test project" in combined_text
    assert "file1.py" in combined_text
    assert "file2.js" in combined_text
    assert "ignore.log" not in combined_text

    # -------------------------------
    # Chunker
    # -------------------------------
    chunker = Chunker(chunk_size=200)  # small chunk for testing
    chunks = chunker.chunk(formatted_texts)
    assert len(chunks) >= 1
    for c in chunks:
        assert len(c) + chunker.header_size <= 200

    # -------------------------------
    # Writer
    # -------------------------------
    output_dir = tmp_path / "output"
    writer = Writer(output_dir)
    written_files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert all(f.exists() for f in written_files)
    assert len(written_files) == len(chunks)

    # Clear output and check
    writer.clear_output()
    assert not any(output_dir.glob("prompt_*.txt"))


#[FILE] tests\test_formatter.py
from snib.formatter import Formatter
from snib.models import Section, FilterStats
from pathlib import Path

def test_formatter_output_sections():
    formatter = Formatter()
    sections = [
        Section(type="info", content="Info text"),
        Section(type="description", content="Desc text"),
        Section(type="task", content="Task text"),
        Section(type="filters", include=["*.py"], exclude=["*.log"], include_stats=FilterStats("included", 2, 2048), exclude_stats=FilterStats("excluded", 1, 1024)),
        Section(type="tree", content="project_tree"),
        Section(type="file", path=Path("example.py"), content="print('hello')")
    ]
    texts = formatter.to_prompt_text(sections)
    combined = "\n".join(texts)
    assert "Info text" in combined
    assert "Desc text" in combined
    assert "Task text" in combined
    assert "example.py" in combined

def test_formatter_size_formatting():
    formatter = Formatter()
    stats = FilterStats(type="included", files=1, size=500)
    assert "500 B" in formatter._format_stats(stats)
    stats.size = 2048
    assert "2.00 KB" in formatter._format_stats(stats)
    stats.size = 5 * 1024**2
    assert "5.00 MB" in formatter._format_stats(stats)


#[FILE] tests\test_scanner.py
from snib.scanner import Scanner
import pytest

def test_file_matches_filters(tmp_path):
    file_a = tmp_path / "a.py"
    file_a.write_text("print('a')")
    file_b = tmp_path / "b.log"
    file_b.write_text("log")

    scanner = Scanner(tmp_path)
    assert scanner._file_matches_filters(file_a, include=["*.py"], exclude=["*.log"])
    assert not scanner._file_matches_filters(file_b, include=["*.py"], exclude=["*.log"])

def test_get_included_files(tmp_path):
    (tmp_path / "a.py").write_text("print('a')")
    (tmp_path / "b.log").write_text("log")
    scanner = Scanner(tmp_path)
    files = scanner._get_included_files(tmp_path, include=["*.py"], exclude=["*.log"])
    assert len(files) == 1
    assert files[0].name == "a.py"


#[FILE] tests\test_utils.py
from snib.utils import handle_include_args, handle_exclude_args, detect_pattern_conflicts, check_include_in_exclude, build_tree
import pytest

def test_handle_include_exclude_args():
    assert handle_include_args([".py", " "]) == [".py"]
    assert handle_include_args(["all"]) == []
    assert handle_exclude_args([".log", ""]) == [".log"]

def test_detect_pattern_conflicts_basic():
    includes = ["*.py", "*.js"]
    excludes = ["*.py", "*.txt"]
    conflicts = detect_pattern_conflicts(includes, excludes)
    assert "*.py" in conflicts

def test_check_include_in_exclude(tmp_path):
    inc_file = tmp_path / "include.txt"
    inc_file.write_text("hello")
    exc_dir = tmp_path / "exclude_dir"
    exc_dir.mkdir()
    problem = check_include_in_exclude(tmp_path, ["include.txt"], ["exclude_dir"])
    assert problem == []

def test_build_tree(tmp_path):
    (tmp_path / "a").mkdir()
    f1 = tmp_path / "a" / "file1.py"
    f1.write_text("print('hi')")
    tree = build_tree(tmp_path, include=["*.py"], exclude=[])
    tree_str = "\n".join(tree)
    assert "file1.py" in tree_str

#[FILE] tests\test_writer.py
from snib.writer import Writer
import pytest

def test_write_and_clear(tmp_path):
    writer = Writer(tmp_path)
    chunks = ["chunk1", "chunk2"]
    files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert len(files) == 2
    for f in files:
        assert f.exists()
    # Clear output
    writer.clear_output()
    assert not any(tmp_path.glob("prompt_*.txt"))


#[FILE] src\snib\chunker.py
import logging

logger = logging.getLogger(__name__)

class Chunker:
    def __init__(self, chunk_size):
        self.chunk_size = chunk_size
        self.header_size = 100  # reserve space for header

    def chunk(self, sections):

        logger.info(f"Using chunk_size={self.chunk_size} chars "
                    f"(≈ {self.chunk_size // 4}-{self.chunk_size // 3} tokens estimated)")

        chunks = []
        current_chunk = ""
        for section in sections:
            lines = section.splitlines(keepends=True)
            for line in lines:
                if len(current_chunk) + len(line) + self.header_size > self.chunk_size:
                    chunks.append(current_chunk)
                    current_chunk = ""
                current_chunk += line
        if current_chunk:
            chunks.append(current_chunk)

        logger.debug(f"Created {len(chunks)} chunk(s)")

        return chunks

#[FILE] src\snib\cli.py
from pathlib import Path
import logging
import typer
import shutil

from .scanner import Scanner
from .utils import handle_include_args, handle_exclude_args, detect_pattern_conflicts, check_include_in_exclude, get_task_choices, get_preset_choices, load_preset
from .config import write_config, load_config, CONFIG_FILE, DEFAULT_CONFIG, DEFAULT_OUTPUT_DIR

logger = logging.getLogger(__name__)
#TODO: using typer.echo instead of logger???

app = typer.Typer(
    help="""snib scans projects and generates prompt-ready chunks.\n
            For help on a specific command, run:\n
                snib COMMAND --help
        """
)

@app.command()
def init(preset: str = typer.Option(None, "--preset", help="Preset to use (feel free to add new ones).", show_choices=True, click_type=get_preset_choices()),
         path: Path = typer.Option(Path.cwd(), "--path", "-p", help="Project directory where snibconfig.toml will be created.")):
    """
    Generates a new snibconfig.toml in your project directory.
    """

    config_path = path / CONFIG_FILE

    if config_path.exists():
        typer.echo(f"{CONFIG_FILE} already exists. No changes made.")
        return

    if preset:
        data = load_preset(preset)
    else:
        data = DEFAULT_CONFIG

    write_config(config_path, data)
    typer.echo(f"{config_path} generated with {(preset + ' preset') if preset else 'defaults'}.")

    #TODO: load config and maybe generate output folder promptready here already

@app.command()
def scan(
    path: Path = typer.Option(None, "--path", "-p", help=f"Path to scan [default: {Path.cwd()}]"),
    description: str = typer.Option(None, "--description", "-d", help="Short project description or changes you want to make [default: empty string]"),
    task: str = typer.Option(None, "--task", "-t", help="Predefined task for AI", case_sensitive=False, show_choices=True, click_type=get_task_choices()),
    include_raw: str = typer.Option("all", "--include", "-i", help="Datatypes or folders/files to included, e.g. *.py, cli.py"),
    exclude_raw: str = typer.Option("", "--exclude", "-e",  help="Datatypes or folders/files to excluded, e.g *.pyc, __pycache__ [default: none]"),
    no_default_exclude: bool = typer.Option(False, "--no-default-excludes", "-E", help="Disable default exclusion"),
    smart: bool = typer.Option(False, "--smart", "-s", help="Smart mode automatically includes only code files and ignores large data/log files"),
    chunk_size: int = typer.Option(None, "--chunk-size", "-c", help="Max number of characters per chunk\nRule of thumb: 1 token ≈ 3-4 chars [default: 30000]"),
    output_dir: Path = typer.Option(None, "--output-dir", "-o", help=f"Folder to save prompt ready data chunks [default: {str(Path.cwd() / 'promptready')}]"),
    force: bool = typer.Option(False, "--force", "-f", help="Force delete existing prompt files and write new ones without validation")     
):
    """
    Scans your project and generates prompt-ready chunks.
    """
    config = DEFAULT_CONFIG
    try:
        config = load_config()
    except FileNotFoundError as e:
        typer.echo(str(e))
        raise typer.Exit(1)

    # combine values: CLI > config 
    path = path or Path(config["project"]["path"])
    description = description or config["project"]["description"]
    task = task or config["instruction"]["task"]

    include_user = handle_include_args(include_raw.split(","))
    exclude_user = handle_exclude_args(exclude_raw.split(","))

    logger.debug(f"User filters after handle_exclude_args: Include: {include_user}, Exclude: {exclude_user}")

    include = include_user or config["filters"]["include"] #TODO: option for config["filters"]["include"] + include_user
    exclude = exclude_user or config["filters"]["exclude"] #TODO: option for config["filters"]["exclude"] + exclude_user

    # add default excludes automatically unless disabled by user
    no_default_exclude = no_default_exclude or config["filters"]["no_default_exclude"]
    if not no_default_exclude:
        exclude = list(set(exclude + config["filters"]["default_exclude"]))
        logger.debug(f"Combined exclude: {exclude}")

    # combine exclude with smart defaults on smart mode enabled
    smart = smart or config["filters"]["smart"]
    if smart:
        include = list(set(include + config["filters"]["smart_include"]))
        exclude = list(set(exclude + config["filters"]["smart_exclude"]))

    # detect filter conflicts (exclude wins) #TODO: set exlude or include wins
    conflicts = detect_pattern_conflicts(include, exclude)
    if conflicts:
        logger.warning(f"Pattern conflicts detected (Exclude wins): {conflicts}")
        # del in include because exlude wins
        include = [p for p in include if not any(p in c for c in conflicts)]

    problematic = check_include_in_exclude(path, include, exclude)
    if problematic:
        logger.warning(f"The following include patterns are inside excluded folders and will be ignored: {problematic}")
        # del in include_patterns because exlude wins
        include = [p for p in include if not any(p in c for c in problematic)]
    
    logger.debug(f"Final include: {include}")
    logger.debug(f"Final exclude: {exclude}")

    chunk_size = chunk_size or config["output"]["chunk_size"]
    output_dir = output_dir or Path(config["output"]["dir"])
    force = force or config["output"]["force"]

    scanner = Scanner(path, config)
    scanner.scan(description, include, exclude, chunk_size, output_dir, force, task)

@app.command()
def clean(
    path: Path = typer.Option(
        Path.cwd(),
        "--path", "-p",
        help="Project directory"
    ),
    force: bool = typer.Option(
        False,
        "--force", "-f",
        help="Do not ask for confirmation"
    ),
    config_only: bool = typer.Option(
        False,
        "--config-only",
        help="Only delete the snibconfig.toml file"
    ),
    output_only: bool = typer.Option(
        False,
        "--output-only",
        help="Only delete the promptready folder"
    ),
):
    """
    Removes the promptready folder and/or config file from your project.
    """
    # checks flags conflict
    if config_only and output_only:
        typer.echo("Error: --config-only and --output-only cannot be used together.")
        raise typer.Exit(code=1)

    config_path = path / CONFIG_FILE
    output_dir = path / DEFAULT_OUTPUT_DIR

    to_delete = []

    if config_only:
        if config_path.exists():
            to_delete.append(config_path)
    elif output_only:
        if output_dir.exists():
            to_delete.append(output_dir)
    else:  # default: delete all
        if config_path.exists():
            to_delete.append(config_path)
        if output_dir.exists():
            to_delete.append(output_dir)

    if not to_delete:
        typer.echo("Nothing to clean - no matching files/folders found.")
        raise typer.Exit()

    typer.echo("The following will be deleted:")
    for item in to_delete:
        typer.echo(f"  - {item}")

    if not force:
        confirm = typer.confirm("Do you want to proceed?", default=False)
        if not confirm:
            typer.echo("Aborted.")
            raise typer.Exit()

    for item in to_delete:
        if item.is_dir():
            shutil.rmtree(item)
        else:
            item.unlink()

    typer.echo(f"Cleaned project directory {path}")

@app.callback()
def main(verbose: bool = False, dev: bool = False):
    """
    Global options.
    """
    log_level = logging.DEBUG if dev else logging.INFO if verbose else logging.WARNING
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )



#[FILE] src\snib\config.py
import toml
from pathlib import Path

DEFAULT_CONFIG = {
    "project": {
        "path": ".", 
        "description": ""
    },
    "instruction": {
        "task": "",
        "task_dict": {
            "debug": "Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.",
            "comment": "Comment: Add comments or explain existing functions and code sections.",
            "refactor": "Refactor: Suggest refactorings to make the code cleaner, more readable, and maintainable.",
            "optimize": "Optimize: Improve efficiency or performance of the code.",
            "summarize": "Summarize: Provide a concise summary of the files or modules.",
            "document": "Document: Generate documentation for functions, classes, or modules.",
            "test": "Test: Create unit tests or test cases for the code.",
            "analyze": "Analyze: Perform static analysis or security checks on the code."
        }
    },
    "filters": {
        "include": [], #TODO: like list
        "exclude": [],    #TODO: like list
        "smart_include": [
            "*.py", "*.js", "*.ts", "*.java", "*.cpp", "*.c", "*.cs", "*.go", "*.rb", "*.php",
            "*.html", "*.css", "*.scss", "*.less", "*.json", "*.yaml", "*.yml", "*.xml", "*.sh",
            "*.bat", "*.ps1", "*.pl", "*.swift", "*.kt", "*.m", "*.r", "*.sql"
        ],
        "smart_exclude": ["*.log", "*.zip", "*.tar", "*.gz", "*.bin", "*.exe", "*.dll", "*.csv"],
        "default_exclude": ["venv", "promptready", "__pycache__", ".git", "snibconfig.toml"],
        "no_default_exclude": False,
        "smart": False
    },
    "output": {
        "dir": "promptready", #TODO: change to folder_name
        "chunk_size": 30000,
        "force": False
    },
    "ai": {
        "model": "gpt-4" #TODO: add for later use with APIs
    }
}

CONFIG_FILE = "snibconfig.toml"

def write_config(path: Path = Path(CONFIG_FILE), content: str = DEFAULT_CONFIG):
    """Generates new _config.toml with defaults or presets."""
    if path.exists():
        raise FileExistsError(f"{path} already exists.")
    toml.dump(content, path.open("w")) #TODO: Trailing Comma -> clean dump for presets (needs fix) -> tomli-w, tomlkit

def load_config(path: Path = Path(CONFIG_FILE)) -> dict:
    """Loads config files or raises FileNotFoundError if not found."""
    if not path.exists():
        raise FileNotFoundError(f"No {CONFIG_FILE} found. Use 'snib init' first.")
    return toml.load(path.open("r"))

DEFAULT_OUTPUT_DIR = "promptready"

#[FILE] src\snib\formatter.py
import logging

from .models import Section, FilterStats

logger = logging.getLogger(__name__)

class Formatter:
    def to_prompt_text(self, sections: list[Section]) -> list[str]:
        logger.debug("Converting sections to promptready text")
        texts = []
        for s in sections:
            if s.type == "info":
                if s.content:
                    texts.append(f"#[INFO]\n{s.content}\n")
                else:
                    logger.info("Only one prompt file; skipping INFO section.")
            elif s.type == "description":
                if s.content:
                    texts.append(f"#[DESCRIPTION]\n{s.content}\n\n")
                else:
                    logger.info("No description provided; skipping DESCRIPTION section.")
            elif s.type == "task":
                if s.content:
                    texts.append(f"#[TASK]\n{s.content}\n\n")
                else:
                    logger.info("No task specified; skipping TASK section.")
            elif s.type == "filters":
                include_text = s.include if s.include else ""
                exclude_text = s.exclude if s.exclude else ""
                include_stats_text = self._format_stats(s.include_stats) if s.include_stats else ""
                exclude_stats_text = self._format_stats(s.exclude_stats) if s.exclude_stats else ""
                
                texts.append(
                    f"#[INCLUDE/EXCLUDE]\n"
                    f"Include patterns: {include_text}\n"
                    f"Exclude patterns: {exclude_text}\n"
                    f"Included files: {include_stats_text}\n"
                    f"Excluded files: {exclude_stats_text}\n\n"
                )
