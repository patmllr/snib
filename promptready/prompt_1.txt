#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/2

#[INCLUDE/EXCLUDE]
Include patterns: 
Exclude patterns: ['__pycache__', 'junk', '.git', 'snibconfig.toml', 'dist', 'promptready', 'venv']
Included files: files: 24, total size: 48.39 KB
Excluded files: files: 2428, total size: 266.61 MB

#[PROJECT TREE]
snib
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ snib
‚îÇ       ‚îú‚îÄ‚îÄ presets
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ custom.toml
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ unity.toml
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ unreal.toml
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ __main__.py
‚îÇ       ‚îú‚îÄ‚îÄ chunker.py
‚îÇ       ‚îú‚îÄ‚îÄ cli.py
‚îÇ       ‚îú‚îÄ‚îÄ config.py
‚îÇ       ‚îú‚îÄ‚îÄ formatter.py
‚îÇ       ‚îú‚îÄ‚îÄ models.py
‚îÇ       ‚îú‚îÄ‚îÄ pipeline.py
‚îÇ       ‚îú‚îÄ‚îÄ scanner.py
‚îÇ       ‚îú‚îÄ‚îÄ utils.py
‚îÇ       ‚îî‚îÄ‚îÄ writer.py
‚îú‚îÄ‚îÄ tests
‚îÇ   ‚îú‚îÄ‚îÄ test_chunker.py
‚îÇ   ‚îú‚îÄ‚îÄ test_cli_scan.py
‚îÇ   ‚îú‚îÄ‚îÄ test_formatter.py
‚îÇ   ‚îú‚îÄ‚îÄ test_scanner.py
‚îÇ   ‚îú‚îÄ‚îÄ test_utils.py
‚îÇ   ‚îî‚îÄ‚îÄ test_writer.py
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ README.md

#[FILE] .gitignore
# Python
__pycache__/
*.py[cod]
*.so
*.egg
*.egg-info/
dist/
build/

# Virtual environments
venv/
.env/
.venv/

# IDE / Editor configs
.vscode/
.idea/

# OS junk
.DS_Store
Thumbs.db

# Logs
*.log

# Project-specific junk
junk/
promptready/

#[FILE] LICENSE
MIT License

Copyright (c) 2025 Patrick M√ºller

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


#[FILE] pyproject.toml
[build-system]
requires = ["hatchling >= 1.26"]
build-backend = "hatchling.build"

[project]
name = "snib"
version = "0.3.0"
authors = [
  { name="Patrick M√ºller", email="patrick.mueller.net@protonmail.com" },
]
description = "snib scans projects and generates prompt-ready chunks"
readme = "README.md"
requires-python = ">=3.9"
classifiers = [
    "Programming Language :: Python :: 3.9",
    "Operating System :: OS Independent",
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Code Generators",
]
license = "MIT"
license-files = ["LICEN[CS]E*"]
dependencies = [
    "typer[all] >=0.9.0"
]

[project.urls]
Homepage = "https://github.com/patmllr/snib"
Issues = "https://github.com/patmllr/snib/issues"

[project.scripts]
snib = "snib.__main__:app"

[tool.hatch.build.targets.wheel]
include = [
    "snib/presets/*.toml"
]

#[FILE] README.md
# Snib ‚úÇÔ∏è

**Snib** is a Python CLI tool to scan your projects, collect source files, and generate **prompt-ready chunks** for use with large language models (LLMs). It helps you prepare clean, structured context from your codebase with include/exclude filters, project trees, and chunking. It supports filtering by file types, folders, regex and can optionally run in **smart mode** to automatically ignore large logs or binary files.

## üöÄ Features 

- Scan entire projects recursively.
- Include or exclude files/folders with globs or explicit paths.
- Generate prompt-ready chunks with configurable size.
- Built-in tasks: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze`.
- Smart mode automatically focuses on source code and ignores unnecessary files.
- Detects conflicts between include/exclude patterns.
- Logs scanning and processing details at INFO or DEBUG level.
- Clean and organized prompt output for large projects.
- Uses three commands `init`, `scan` and `clean`.

---

## üì¶ Installation 

```bash
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.3.0-py3-none-any.whl
```

Alternatively download the latest wheel here: [Latest Release](https://github.com/patmllr/snib/releases/latest)

### üß∞ Recommended setup

Create a Python virtual environment inside your project folder and install `snib` in the `venv`:

```bash
python -m venv venv
source venv/Scripts/activate   # Windows Git Bash
source venv/bin/activate       # Linux / macOS
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.3.0-py3-none-any.whl
```

## ‚ö° CLI Usage

`snib` scans projects and generates prompt-ready chunks.

```bash
snib [OPTIONS] COMMAND [ARGS]...
```

### ‚öôÔ∏è Global Options

| Option                     | Description                              |
| -------------------------- | ---------------------------------------- |
| `--verbose / --no-verbose` | Show INFO logs (default: `--no-verbose`) |
| `--dev / --no-dev`         | Show DEBUG logs (default: `--no-dev`)    |
| `--install-completion`     | Install shell completion                 |
| `--show-completion`        | Show completion script                   |
| `--help`                   | Show this message and exit               |

### üì¶ Commands

`init`

Generates a new `snibconfig.toml` in your project directory.

| Option        | Short | Description                                           |
| ------------- | ----- | ----------------------------------------------------- |
| `--preset`    |       | Preset to use: `unity`, `unreal` (extendable)         |
| `--path PATH` | `-p`  | Target directory (default: current working directory) |
| `--help`      |       | Show this message and exit                            |

`scan`

Scans your project and generates prompt-ready chunks.

| Option                  | Short | Description                                                                                             |
| ----------------------- | ----- | ------------------------------------------------------------------------------------------------------- |
| `--path PATH`           | `-p`  | Path to scan (default: current directory)                                                               |
| `--description TEXT`    | `-d`  | Short project description or changes you want to make                                                   |
| `--task`                | `-t`  | Predefined task: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze` |
| `--include TEXT`        | `-i`  | File types or folders to include, e.g., `*.py, cli.py`                                                  |
| `--exclude TEXT`        | `-e`  | File types or folders to exclude, e.g., `*.pyc, __pycache__`                                            |
| `--no-default-excludes` | `-E`  | Disable automatic exclusion of `venv`, `promptready`, `__pycache__`                                     |
| `--smart`               | `-s`  | Smart mode: only code files, ignores logs/large files                                                   |
| `--chunk-size INT`      | `-c`  | Max characters per chunk (default: 30,000)                                                              |
| `--output-dir PATH`     | `-o`  | Output folder (default: `promptready`)                                                                  |
| `--force`               | `-f`  | Force overwrite existing prompt files                                                                   |
| `--help`                |       | Show this message and exit                                                                              |

`clean`

Removes the `promptready` folder and/or config file from your project.

| Option          | Short | Description                                    |
| --------------- | ----- | ---------------------------------------------- |
| `--path PATH`   | `-p`  | Project directory (default: current directory) |
| `--force`       | `-f`  | Do not ask for confirmation                    |
| `--config-only` |       | Only delete `snibconfig.toml`                  |
| `--output-only` |       | Only delete the `promptready` folder           |
| `--help`        |       | Show this message and exit                     |

## üëç Rule of Thumb for Chunk Sizes

Since snib chunks by characters, the following guidelines can help to estimate the chunk size:

| Model / LLM           | Max Context (Tokens) | Recommended `--chunk-size` (Chars) | Notes                                      |
| --------------------- | -------------------- | ---------------------------------- | ------------------------------------------ |
| LLaMA 2 (7B/13B)      | 4,000                | 12,000 ‚Äì 14,000                    | 1 token ‚âà 3‚Äì4 chars                        |
| Mistral 7B            | 8,000                | 28,000                             | Leave a safety margin                      |
| GPT-4 classic         | 8,000                | 28,000                             |                                            |
| GPT-4-32k             | 32,000               | 110,000                            |                                            |
| GPT-4o / GPT-5 (128k) | 128,000              | 450,000 ‚Äì 500,000                  | Very large models, massive chunks possible |

## üéÆ Presets

Snib comes with ready-to-use presets:

- `unity.toml` ‚Üí Configured for Unity projects (*.cs, *.shader, ‚Ä¶)
- `unreal.toml` ‚Üí Configured for Unreal projects (extendable)

You can create your own presets by adding new .toml files to the presets directory.

## üóÇÔ∏è Example 

```bash
snib init

snib --verbose scan -e "dist, junk" --chunk-size 100000 --smart
```

```text
#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/4

#[DESCRIPTION]
This is a demo.

#[TASK]
Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.

#[INCLUDE/EXCLUDE]
Include patterns: ['*.py']
Exclude patterns: ['promptready', 'dist', 'junk', 'venv', '__pycache__']
Included files: files: 16, total size: 28.86 KB
Excluded files: files: 1943, total size: 262.11 MB

#[PROJECT TREE]
snib
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îî‚îÄ‚îÄ snib
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ __main__.py
‚îÇ       ‚îú‚îÄ‚îÄ ...
‚îÇ       ‚îî‚îÄ‚îÄ writer.py
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ test_chunker.py
    ‚îú‚îÄ‚îÄ ...
    ‚îî‚îÄ‚îÄ test_writer.py

#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

...

#[INFO]
Prompt file 4/4

...
```

After running snib, a `promptready` folder is generated with prompt files ready to get copied to the clipboard:

```text
prompt_1.txt
...
prompt_4.txt
```

## üß† Best Practices

- Always install snib inside a virtual environment.
- `venv` and `promptready` are automatically excluded from scans.
- Use `--smart` to focus on code and avoid unnecessary large files.
- Adjust `--chunk-size` based on your target LLM and the table above.

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/your-feature`
3. Commit your changes: `git commit -m "Add new feature"`
4. Push to branch: `git push origin feature/your-feature`
5. Open a Pull Request

## üìù Notes

- Snib is designed to be lightweight and easily integrated into CI/CD pipelines.
- Works cross-platform (Windows, Linux, macOS).
- Automatically inserts headers in multi-chunk outputs to guide LLM processing.

## üìú License

MIT License ¬© 2025 Patrick M√ºller

#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

def test_chunker_splits_correctly():
    chunker = Chunker(chunk_size=50)
    sections = ["line1\nline2\nline3", "line4\nline5"]
    chunks = chunker.chunk(sections)
    
    for c in chunks:
        assert len(c) + chunker.header_size <= chunker.chunk_size
    assert "".join(chunks) == "line1\nline2\nline3line4\nline5"

def test_chunker_empty_input():
    chunker = Chunker(chunk_size=50)
    chunks = chunker.chunk([])
    assert chunks == []


#[FILE] tests\test_cli_scan.py
import pytest
from pathlib import Path
from snib.scanner import Scanner
from snib.formatter import Formatter
from snib.chunker import Chunker
from snib.writer import Writer
from snib.models import Section

def test_end_to_end_scan(tmp_path):
    # -------------------------------
    # Setup fake project files
    # -------------------------------
    # Create folders and files
    (tmp_path / "src").mkdir()
    (tmp_path / "src" / "file1.py").write_text("print('hello')")
    (tmp_path / "src" / "file2.js").write_text("console.log('hi')")
    (tmp_path / "README.md").write_text("# Project README")
    (tmp_path / "ignore.log").write_text("This should be ignored")

    # -------------------------------
    # Initialize Scanner
    # -------------------------------
    scanner = Scanner(tmp_path)

    include_patterns = ["*.py", "*.js"]
    exclude_patterns = ["*.log"]

    sections = scanner._collect_sections(
        description="Test project",
        include=include_patterns,
        exclude=exclude_patterns,
        task="test"
    )

    # Check sections collected
    section_types = [s.type for s in sections]
    assert "description" in section_types
    assert "task" in section_types
    assert "filters" in section_types
    assert "tree" in section_types
    assert any(s.type == "file" for s in sections)

    # -------------------------------
    # Formatter
    # -------------------------------
    formatter = Formatter()
    formatted_texts = formatter.to_prompt_text(sections)
    combined_text = "\n".join(formatted_texts)
    assert "Test project" in combined_text
    assert "file1.py" in combined_text
    assert "file2.js" in combined_text
    assert "ignore.log" not in combined_text

    # -------------------------------
    # Chunker
    # -------------------------------
    chunker = Chunker(chunk_size=200)  # small chunk for testing
    chunks = chunker.chunk(formatted_texts)
    assert len(chunks) >= 1
    for c in chunks:
        assert len(c) + chunker.header_size <= 200

    # -------------------------------
    # Writer
    # -------------------------------
    output_dir = tmp_path / "output"
    writer = Writer(output_dir)
    written_files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert all(f.exists() for f in written_files)
    assert len(written_files) == len(chunks)

    # Clear output and check
    writer.clear_output()
    assert not any(output_dir.glob("prompt_*.txt"))


#[FILE] tests\test_formatter.py
from snib.formatter import Formatter
from snib.models import Section, FilterStats
from pathlib import Path

def test_formatter_output_sections():
    formatter = Formatter()
    sections = [
        Section(type="info", content="Info text"),
        Section(type="description", content="Desc text"),
        Section(type="task", content="Task text"),
        Section(type="filters", include=["*.py"], exclude=["*.log"], include_stats=FilterStats("included", 2, 2048), exclude_stats=FilterStats("excluded", 1, 1024)),
        Section(type="tree", content="project_tree"),
        Section(type="file", path=Path("example.py"), content="print('hello')")
    ]
    texts = formatter.to_prompt_text(sections)
    combined = "\n".join(texts)
    assert "Info text" in combined
    assert "Desc text" in combined
    assert "Task text" in combined
    assert "example.py" in combined

def test_formatter_size_formatting():
    formatter = Formatter()
    stats = FilterStats(type="included", files=1, size=500)
    assert "500 B" in formatter._format_stats(stats)
    stats.size = 2048
    assert "2.00 KB" in formatter._format_stats(stats)
    stats.size = 5 * 1024**2
    assert "5.00 MB" in formatter._format_stats(stats)


#[FILE] tests\test_scanner.py
from snib.scanner import Scanner
import pytest

def test_file_matches_filters(tmp_path):
    file_a = tmp_path / "a.py"
    file_a.write_text("print('a')")
    file_b = tmp_path / "b.log"
    file_b.write_text("log")

    scanner = Scanner(tmp_path)
    assert scanner._file_matches_filters(file_a, include=["*.py"], exclude=["*.log"])
    assert not scanner._file_matches_filters(file_b, include=["*.py"], exclude=["*.log"])

def test_get_included_files(tmp_path):
    (tmp_path / "a.py").write_text("print('a')")
    (tmp_path / "b.log").write_text("log")
    scanner = Scanner(tmp_path)
    files = scanner._get_included_files(tmp_path, include=["*.py"], exclude=["*.log"])
    assert len(files) == 1
    assert files[0].name == "a.py"


#[FILE] tests\test_utils.py
from snib.utils import handle_include_args, handle_exclude_args, detect_pattern_conflicts, check_include_in_exclude, build_tree
import pytest

def test_handle_include_exclude_args():
    assert handle_include_args([".py", " "]) == [".py"]
    assert handle_include_args(["all"]) == []
    assert handle_exclude_args([".log", ""]) == [".log"]

def test_detect_pattern_conflicts_basic():
    includes = ["*.py", "*.js"]
    excludes = ["*.py", "*.txt"]
    conflicts = detect_pattern_conflicts(includes, excludes)
    assert "*.py" in conflicts

def test_check_include_in_exclude(tmp_path):
    inc_file = tmp_path / "include.txt"
    inc_file.write_text("hello")
    exc_dir = tmp_path / "exclude_dir"
    exc_dir.mkdir()
    problem = check_include_in_exclude(tmp_path, ["include.txt"], ["exclude_dir"])
    assert problem == []

def test_build_tree(tmp_path):
    (tmp_path / "a").mkdir()
    f1 = tmp_path / "a" / "file1.py"
    f1.write_text("print('hi')")
    tree = build_tree(tmp_path, include=["*.py"], exclude=[])
    tree_str = "\n".join(tree)
    assert "file1.py" in tree_str

#[FILE] tests\test_writer.py
from snib.writer import Writer
import pytest

def test_write_and_clear(tmp_path):
    writer = Writer(tmp_path)
    chunks = ["chunk1", "chunk2"]
    files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert len(files) == 2
    for f in files:
        assert f.exists()
    # Clear output
    writer.clear_output()
    assert not any(tmp_path.glob("prompt_*.txt"))


#[FILE] src\snib\chunker.py
import logging

logger = logging.getLogger(__name__)


class Chunker:
    def __init__(self, chunk_size):
        self.chunk_size = chunk_size
        self.header_size = 100  # reserve space for header

    def chunk(self, sections):

        logger.info(
            f"Using chunk_size={self.chunk_size} chars "
            f"(‚âà {self.chunk_size // 4}-{self.chunk_size // 3} tokens estimated)"
        )

        chunks = []
        current_chunk = ""
        for section in sections:
            lines = section.splitlines(keepends=True)
            for line in lines:
                if len(current_chunk) + len(line) + self.header_size > self.chunk_size:
                    chunks.append(current_chunk)
                    current_chunk = ""
                current_chunk += line
        if current_chunk:
            chunks.append(current_chunk)

        logger.debug(f"Created {len(chunks)} chunk(s)")

        return chunks


#[FILE] src\snib\cli.py
import logging
from pathlib import Path

import typer

from .pipeline import SnibPipeline
from .utils import get_preset_choices, get_task_choices

logger = logging.getLogger(__name__)
pipeline = SnibPipeline()

app = typer.Typer(
    help="""snib scans projects and generates prompt-ready chunks.\n
            For help on a specific command, run:\n
                snib COMMAND --help
        """
)


@app.command()
def init(
    path: Path = typer.Option(
        Path.cwd(),
        "--path",
        "-p",
        help="Project directory where snibconfig.toml will be created.",
    ),
    preset: str = typer.Option(
        None,
        "--preset",
        help="Preset to use (feel free to add new ones).",
        show_choices=True,
        click_type=get_preset_choices(),
    ),
):
    """
    Generates a new snibconfig.toml in your project directory.
    """
    pipeline.init(path=path, preset=preset)


@app.command()
def scan(
    path: Path = typer.Option(
        None, "--path", "-p", help=f"Path to scan [default: {Path.cwd()}]"
    ),
    description: str = typer.Option(
        None,
        "--description",
        "-d",
        help="Short project description or changes you want to make [default: empty string]",
    ),
    task: str = typer.Option(
        None,
        "--task",
        "-t",
        help="Predefined task for AI",
        case_sensitive=False,
        show_choices=True,
        click_type=get_task_choices(),
    ),
    include_raw: str = typer.Option(
        "all",
        "--include",
        "-i",
        help="Datatypes or folders/files to included, e.g. *.py, cli.py",
    ),
    exclude_raw: str = typer.Option(
        "",
        "--exclude",
        "-e",
        help="Datatypes or folders/files to excluded, e.g *.pyc, __pycache__ [default: none]",
    ),
    no_default_exclude: bool = typer.Option(
        False, "--no-default-excludes", "-E", help="Disable default exclusion"
    ),
    smart: bool = typer.Option(
        False,
        "--smart",
        "-s",
        help="Smart mode automatically includes only code files and ignores large data/log files",
    ),
    chunk_size: int = typer.Option(
        None,
        "--chunk-size",
        "-c",
        help="Max number of characters per chunk\nRule of thumb: 1 token ‚âà 3-4 chars [default: 30000]",
    ),
    output_dir: Path = typer.Option(
        None,
        "--output-dir",
        "-o",
        help=f"Folder to save prompt ready data chunks [default: {str(Path.cwd() / 'promptready')}]",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Force delete existing prompt files and write new ones without validation",
    ),
):
    """
    Scans your project and generates prompt-ready chunks.
    """
    pipeline.scan(
        path=path,
        description=description,
        task=task,
        include_raw=include_raw,
        exclude_raw=exclude_raw,
        no_default_exclude=no_default_exclude,
        smart=smart,
        chunk_size=chunk_size,
        output_dir=output_dir,
        force=force,
    )


@app.command()
def clean(
    path: Path = typer.Option(Path.cwd(), "--path", "-p", help="Project directory"),
    force: bool = typer.Option(
        False, "--force", "-f", help="Do not ask for confirmation"
    ),
    config_only: bool = typer.Option(
        False, "--config-only", help="Only delete the snibconfig.toml file"
    ),
    output_only: bool = typer.Option(
        False, "--output-only", help="Only delete the promptready folder"
    ),
):
    """
    Removes the promptready folder and/or config file from your project.
    """
    pipeline.clean(
        path=path, force=force, config_only=config_only, output_only=output_only
    )


@app.callback()
def main(verbose: bool = False, dev: bool = False):
    """
    Global options.
    """
    log_level = logging.DEBUG if dev else logging.INFO if verbose else logging.WARNING
    logging.basicConfig(
        level=log_level, format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )


#[FILE] src\snib\config.py
from importlib import resources
from pathlib import Path

import toml

from . import presets  # reference to snib.presets

DEFAULT_CONFIG = {
    "project": {"path": ".", "description": ""},
    "instruction": {
        "task": "",
        "task_dict": {
            "debug": "Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.",
            "comment": "Comment: Add comments or explain existing functions and code sections.",
            "refactor": "Refactor: Suggest refactorings to make the code cleaner, more readable, and maintainable.",
            "optimize": "Optimize: Improve efficiency or performance of the code.",
            "summarize": "Summarize: Provide a concise summary of the files or modules.",
            "document": "Document: Generate documentation for functions, classes, or modules.",
            "test": "Test: Create unit tests or test cases for the code.",
            "analyze": "Analyze: Perform static analysis or security checks on the code.",
        },
    },
    "filters": {
        "include": [],  # TODO: like list
        "exclude": [],  # TODO: like list
        "smart_include": [
            "*.py",
            "*.js",
            "*.ts",
            "*.java",
            "*.cpp",
            "*.c",
            "*.cs",
            "*.go",
            "*.rb",
            "*.php",
            "*.html",
            "*.css",
            "*.scss",
            "*.less",
            "*.json",
            "*.yaml",
            "*.yml",
            "*.xml",
            "*.sh",
            "*.bat",
            "*.ps1",
            "*.pl",
            "*.swift",
            "*.kt",
            "*.m",
            "*.r",
            "*.sql",
        ],
        "smart_exclude": [
            "*.log",
            "*.zip",
            "*.tar",
            "*.gz",
            "*.bin",
            "*.exe",
            "*.dll",
            "*.csv",
        ],
        "default_exclude": [
            "venv",
            "promptready",
            "__pycache__",
            ".git",
            "snibconfig.toml",
        ],
        "no_default_exclude": False,
        "smart": False,
    },
    "output": {
        "dir": "promptready",  # TODO: change to folder_name
        "chunk_size": 30000,
        "force": False,
    },
    "ai": {"model": "gpt-4"},  # TODO: add for later use with APIs
}

CONFIG_FILE = "snibconfig.toml"
DEFAULT_OUTPUT_DIR = "promptready"


def write_config(path: Path = Path(CONFIG_FILE), content: str = DEFAULT_CONFIG):
    """Generates new _config.toml with defaults or presets."""
    if path.exists():
        raise FileExistsError(f"{path} already exists.")
    toml.dump(
        content, path.open("w")
    )  # TODO: Trailing Comma -> clean dump for presets (needs fix) -> tomli-w, tomlkit


def load_config(path: Path = Path(CONFIG_FILE)) -> dict:
    """Loads config files or raises FileNotFoundError if not found."""
    if not path.exists():
        raise FileNotFoundError(f"No {CONFIG_FILE} found. Use 'snib init' first.")
    return toml.load(path.open("r"))


def load_preset(name: str) -> dict:
    preset_file = f"{name}.toml"
    try:
        with resources.open_text(presets, preset_file) as f:
            return toml.load(f)
    except FileNotFoundError:
        raise ValueError(f"Preset '{name}' not found")


#[FILE] src\snib\formatter.py
import logging

from .models import FilterStats, Section
from .utils import format_size

logger = logging.getLogger(__name__)


class Formatter:
    def to_prompt_text(self, sections: list[Section]) -> list[str]:
        logger.debug("Converting sections to promptready text")
        texts = []
        for s in sections:
            if s.type == "info":
                if s.content:
                    texts.append(f"#[INFO]\n{s.content}\n")
                else:
                    logger.info("Only one prompt file; skipping INFO section.")
            elif s.type == "description":
                if s.content:
                    texts.append(f"#[DESCRIPTION]\n{s.content}\n\n")
                else:
                    logger.info(
                        "No description provided; skipping DESCRIPTION section."
                    )
            elif s.type == "task":
                if s.content:
                    texts.append(f"#[TASK]\n{s.content}\n\n")
                else:
                    logger.info("No task specified; skipping TASK section.")
            elif s.type == "filters":
                include_text = s.include if s.include else ""
                exclude_text = s.exclude if s.exclude else ""
                include_stats_text = (
                    self._format_stats(s.include_stats) if s.include_stats else ""
                )
                exclude_stats_text = (
                    self._format_stats(s.exclude_stats) if s.exclude_stats else ""
                )

                texts.append(
                    f"#[INCLUDE/EXCLUDE]\n"
                    f"Include patterns: {include_text}\n"
                    f"Exclude patterns: {exclude_text}\n"
                    f"Included files: {include_stats_text}\n"
                    f"Excluded files: {exclude_stats_text}\n\n"
                )
            elif s.type == "tree":
                texts.append(f"#[PROJECT TREE]\n{s.content}\n\n")
            elif s.type == "file":
                texts.append(f"#[FILE] {s.path}\n{s.content}\n\n")
        return texts

    def _format_stats(self, stats: FilterStats) -> str:
        """
        Formats FilterStats readably with format_size()
        Shows number of files and total size in B/KB/MB.
        """
        return f"files: {stats.files}, total size: {format_size(stats.size)}"


#[FILE] src\snib\models.py
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

@dataclass
class FilterStats:
    type: str
    files: int = 0
    size: int = 0

@dataclass
class Section:
    type: str
    content: str = ""   
    path: Optional[Path] = None
    include: Optional[list[str]] = None
    exclude: Optional[list[str]] = None
    include_stats: Optional[FilterStats] = None
    exclude_stats: Optional[FilterStats] = None




#[FILE] src\snib\pipeline.py
import logging
import shutil
from pathlib import Path

import typer

from .config import (
    CONFIG_FILE,
    DEFAULT_CONFIG,
    DEFAULT_OUTPUT_DIR,
    load_config,
    load_preset,
    write_config,
)
from .scanner import Scanner
from .utils import (
    check_include_in_exclude,
    detect_pattern_conflicts,
    handle_exclude_args,
    handle_include_args,
)

logger = logging.getLogger(__name__)


class SnibPipeline:
