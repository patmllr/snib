#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/2

#[INCLUDE/EXCLUDE]
Include patterns: 
Exclude patterns: ['.git', 'promptready', 'venv', '__pycache__', 'dist', 'junk']
Included files: files: 20, total size: 38.27 KB
Excluded files: files: 1938, total size: 262.16 MB

#[PROJECT TREE]
snib
├── src
│   └── snib
│       ├── __init__.py
│       ├── __main__.py
│       ├── chunker.py
│       ├── cli.py
│       ├── constants.py
│       ├── formatter.py
│       ├── models.py
│       ├── scanner.py
│       ├── utils.py
│       └── writer.py
├── tests
│   ├── test_chunker.py
│   ├── test_cli_scan.py
│   ├── test_formatter.py
│   ├── test_scanner.py
│   ├── test_utils.py
│   └── test_writer.py
├── .gitignore
├── LICENSE
├── pyproject.toml
└── README.md

#[FILE] .gitignore
# Python
__pycache__/
*.py[cod]
*.so
*.egg
*.egg-info/
dist/
build/

# Virtual environments
venv/
.env/
.venv/

# IDE / Editor configs
.vscode/
.idea/

# OS junk
.DS_Store
Thumbs.db

# Logs
*.log

# Project-specific junk
junk/

#[FILE] LICENSE
MIT License

Copyright (c) 2025 Patrick Müller

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


#[FILE] pyproject.toml
[build-system]
requires = ["hatchling >= 1.26"]
build-backend = "hatchling.build"

[project]
name = "snib"
version = "0.2.1"
authors = [
  { name="Patrick Müller", email="patrick.mueller.net@protonmail.com" },
]
description = "snib scans projects and generates prompt-ready chunks"
readme = "README.md"
requires-python = ">=3.9"
classifiers = [
    "Programming Language :: Python :: 3.9",
    "Operating System :: OS Independent",
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "Topic :: Software Development :: Code Generators",
]
license = "MIT"
license-files = ["LICEN[CS]E*"]

[project.urls]
Homepage = "https://github.com/patmllr/snib"
Issues = "https://github.com/patmllr/snib/issues"

[project.scripts]
snib = "snib.__main__:main"

#[FILE] README.md
# Snib

**Snib** is a CLI Python tool to scan projects, collect source files, and generate **prompt-ready chunks** for use with large language models (LLMs). It supports filtering by file types, folders, regex and can optionally run in **smart mode** to automatically ignore large logs or binary files.

## Features

- Scan entire projects recursively.
- Include or exclude files/folders with globs or explicit paths.
- Generate prompt-ready chunks with configurable size.
- Built-in tasks: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze`.
- Smart mode automatically focuses on source code and ignores unnecessary files.
- Detects conflicts between include/exclude patterns.
- Logs scanning and processing details at INFO or DEBUG level.
- Clean and organized prompt output for large projects.

---

## Installation

```bash
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.2.1-py3-none-any.whl
```

Alternatively download the latest wheel here: [Latest Release](https://github.com/patmllr/snib/releases/latest)

### Recommended setup

Create a Python virtual environment inside your project folder and install `snib` in the `venv`:

```bash
python -m venv venv
source venv/Scripts/activate   # Windows Git Bash
source venv/bin/activate       # Linux / macOS
pip install https://github.com/patmllr/snib/releases/latest/download/snib-0.2.1-py3-none-any.whl
```

## Usage

```bash
snib --path ./my_project \
     --description "This is a demo." \
     --include "*.py, test.js, src/test" \
     --exclude "*.log, *.tmp" \
     --chunk-size 10000 \
     --output promptready \
     --task debug \
     --smart \
     --verbose
```

### Options

| Option                  | Short | Description                                                                                             |
| ----------------------- | ----- | ------------------------------------------------------------------------------------------------------- |
| `--path`                | `-p`  | Path to scan (default: current directory)                                                               |
| `--description`         | `-d`  | Short description of the project/changes                                                                |
| `--include`             | `-i`  | File types or folders to include, e.g., `*.py, cli.py`                                                  |
| `--exclude`             | `-e`  | File types or folders to exclude, e.g., `*.pyc, __pycache__`                                            |
| `--chunk-size`          | `-c`  | Max characters per chunk (default: 30,000)                                                              |
| `--output`              | `-o`  | Folder to save prompt-ready chunks (default: `promptready`)                                             |
| `--force`               | `-f`  | Force overwrite existing prompt files                                                                   |
| `--task`                | `-t`  | Predefined task: `debug`, `comment`, `refactor`, `optimize`, `summarize`, `document`, `test`, `analyze` |
| `--verbose`             | `-V`  | Show INFO logs                                                                                          |
| `--dev`                 | `-D`  | Show DEBUG logs                                                                                         |
| `--smart`               | `-s`  | Smart mode: includes only code files, ignores large/log files                                           |
| `--no-default-excludes` | `-E`  | Disable automatic exclusion of `venv`, `promptready`, `__pycache__`                                     |

## Rule of Thumb for Chunk Sizes

Since snib chunks by characters, the following guidelines can help to estimate the chunk size:

| Model / LLM           | Max Context (Tokens) | Recommended `--chunk-size` (Chars) | Notes                                      |
| --------------------- | -------------------- | ---------------------------------- | ------------------------------------------ |
| LLaMA 2 (7B/13B)      | 4,000                | 12,000 – 14,000                    | 1 token ≈ 3–4 chars                        |
| Mistral 7B            | 8,000                | 28,000                             | Leave a safety margin                      |
| GPT-4 classic         | 8,000                | 28,000                             |                                            |
| GPT-4-32k             | 32,000               | 110,000                            |                                            |
| GPT-4o / GPT-5 (128k) | 128,000              | 450,000 – 500,000                  | Very large models, massive chunks possible |

## Example Project Scan

```text
#[INFO]
Please do not give output until all prompt files are sent. Prompt file 1/4

#[DESCRIPTION]
This is a demo.

#[TASK]
Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.

#[INCLUDE/EXCLUDE]
Include patterns: ['*.py']
Exclude patterns: ['promptready', 'dist', 'junk', 'venv', '__pycache__']
Included files: files: 16, total size: 28.86 KB
Excluded files: files: 1943, total size: 262.11 MB

#[PROJECT TREE]
snib
├── src
│   └── snib
│       ├── __init__.py
│       ├── __main__.py
│       ├── chunker.py
│       ├── cli.py
│       ├── constants.py
│       ├── formatter.py
│       ├── models.py
│       ├── scanner.py
│       ├── utils.py
│       └── writer.py
└── tests
    ├── test_chunker.py
    ├── test_cli_scan.py
    ├── test_formatter.py
    ├── test_scanner.py
    ├── test_utils.py
    └── test_writer.py

#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

...

#[INFO]
Prompt file 4/4

        for file_path in self.output_dir.glob("prompt_*.txt"):
            if file_path.is_file():
                file_path.unlink()
        logger.info(f"Cleared existing prompt file(s) in {self.output_dir}")


#[FILE] src\snib\__init__.py


#[FILE] src\snib\__main__.py
from .cli import main

if __name__ == "__main__":
    main()
```

After running snib, a `promptready` folder is generated with prompt files ready to get copied to the clipboard:

```text
prompt_1.txt
...
promt_4.txt
```

## Best Practices

- Always install snib inside a virtual environment.
- `venv` and `promptready` are automatically excluded from scans.
- Use `--smart` to focus on code and avoid unnecessary large files.
- Adjust `--chunk-size` based on your target LLM and the table above.
- If followed these instructions just exclude some folders you don't need to be scanned and run snib on your project like:

```bash
snib -e "dist, junk" --chunk-size 100000 --smart --verbose
```

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/your-feature`
3. Commit your changes: `git commit -m "Add new feature"`
4. Push to branch: `git push origin feature/your-feature`
5. Open a Pull Request

## Notes

- Snib is designed to be lightweight and easily integrated into CI/CD pipelines.
- Works cross-platform (Windows, Linux, macOS).
- Automatically inserts headers in multi-chunk outputs to guide LLM processing.


#[FILE] tests\test_chunker.py
import pytest
from snib.chunker import Chunker

def test_chunker_splits_correctly():
    chunker = Chunker(chunk_size=50)
    sections = ["line1\nline2\nline3", "line4\nline5"]
    chunks = chunker.chunk(sections)
    
    for c in chunks:
        assert len(c) + chunker.header_size <= chunker.chunk_size
    assert "".join(chunks) == "line1\nline2\nline3line4\nline5"

def test_chunker_empty_input():
    chunker = Chunker(chunk_size=50)
    chunks = chunker.chunk([])
    assert chunks == []


#[FILE] tests\test_cli_scan.py
import pytest
from pathlib import Path
from snib.scanner import Scanner
from snib.formatter import Formatter
from snib.chunker import Chunker
from snib.writer import Writer
from snib.models import Section

def test_end_to_end_scan(tmp_path):
    # -------------------------------
    # Setup fake project files
    # -------------------------------
    # Create folders and files
    (tmp_path / "src").mkdir()
    (tmp_path / "src" / "file1.py").write_text("print('hello')")
    (tmp_path / "src" / "file2.js").write_text("console.log('hi')")
    (tmp_path / "README.md").write_text("# Project README")
    (tmp_path / "ignore.log").write_text("This should be ignored")

    # -------------------------------
    # Initialize Scanner
    # -------------------------------
    scanner = Scanner(tmp_path)

    include_patterns = ["*.py", "*.js"]
    exclude_patterns = ["*.log"]

    sections = scanner._collect_sections(
        description="Test project",
        include=include_patterns,
        exclude=exclude_patterns,
        task="test"
    )

    # Check sections collected
    section_types = [s.type for s in sections]
    assert "description" in section_types
    assert "task" in section_types
    assert "filters" in section_types
    assert "tree" in section_types
    assert any(s.type == "file" for s in sections)

    # -------------------------------
    # Formatter
    # -------------------------------
    formatter = Formatter()
    formatted_texts = formatter.to_prompt_text(sections)
    combined_text = "\n".join(formatted_texts)
    assert "Test project" in combined_text
    assert "file1.py" in combined_text
    assert "file2.js" in combined_text
    assert "ignore.log" not in combined_text

    # -------------------------------
    # Chunker
    # -------------------------------
    chunker = Chunker(chunk_size=200)  # small chunk for testing
    chunks = chunker.chunk(formatted_texts)
    assert len(chunks) >= 1
    for c in chunks:
        assert len(c) + chunker.header_size <= 200

    # -------------------------------
    # Writer
    # -------------------------------
    output_dir = tmp_path / "output"
    writer = Writer(output_dir)
    written_files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert all(f.exists() for f in written_files)
    assert len(written_files) == len(chunks)

    # Clear output and check
    writer.clear_output()
    assert not any(output_dir.glob("prompt_*.txt"))


#[FILE] tests\test_formatter.py
from snib.formatter import Formatter
from snib.models import Section, FilterStats
from pathlib import Path

def test_formatter_output_sections():
    formatter = Formatter()
    sections = [
        Section(type="info", content="Info text"),
        Section(type="description", content="Desc text"),
        Section(type="task", content="Task text"),
        Section(type="filters", include=["*.py"], exclude=["*.log"], include_stats=FilterStats("included", 2, 2048), exclude_stats=FilterStats("excluded", 1, 1024)),
        Section(type="tree", content="project_tree"),
        Section(type="file", path=Path("example.py"), content="print('hello')")
    ]
    texts = formatter.to_prompt_text(sections)
    combined = "\n".join(texts)
    assert "Info text" in combined
    assert "Desc text" in combined
    assert "Task text" in combined
    assert "example.py" in combined

def test_formatter_size_formatting():
    formatter = Formatter()
    stats = FilterStats(type="included", files=1, size=500)
    assert "500 B" in formatter._format_stats(stats)
    stats.size = 2048
    assert "2.00 KB" in formatter._format_stats(stats)
    stats.size = 5 * 1024**2
    assert "5.00 MB" in formatter._format_stats(stats)


#[FILE] tests\test_scanner.py
from snib.scanner import Scanner
import pytest

def test_file_matches_filters(tmp_path):
    file_a = tmp_path / "a.py"
    file_a.write_text("print('a')")
    file_b = tmp_path / "b.log"
    file_b.write_text("log")

    scanner = Scanner(tmp_path)
    assert scanner._file_matches_filters(file_a, include=["*.py"], exclude=["*.log"])
    assert not scanner._file_matches_filters(file_b, include=["*.py"], exclude=["*.log"])

def test_get_included_files(tmp_path):
    (tmp_path / "a.py").write_text("print('a')")
    (tmp_path / "b.log").write_text("log")
    scanner = Scanner(tmp_path)
    files = scanner._get_included_files(tmp_path, include=["*.py"], exclude=["*.log"])
    assert len(files) == 1
    assert files[0].name == "a.py"


#[FILE] tests\test_utils.py
from snib.utils import handle_include_args, handle_exclude_args, detect_pattern_conflicts, check_include_in_exclude, build_tree
import pytest

def test_handle_include_exclude_args():
    assert handle_include_args([".py", " "]) == [".py"]
    assert handle_include_args(["all"]) == []
    assert handle_exclude_args([".log", ""]) == [".log"]

def test_detect_pattern_conflicts_basic():
    includes = ["*.py", "*.js"]
    excludes = ["*.py", "*.txt"]
    conflicts = detect_pattern_conflicts(includes, excludes)
    assert "*.py" in conflicts

def test_check_include_in_exclude(tmp_path):
    inc_file = tmp_path / "include.txt"
    inc_file.write_text("hello")
    exc_dir = tmp_path / "exclude_dir"
    exc_dir.mkdir()
    problem = check_include_in_exclude(tmp_path, ["include.txt"], ["exclude_dir"])
    assert problem == []

def test_build_tree(tmp_path):
    (tmp_path / "a").mkdir()
    f1 = tmp_path / "a" / "file1.py"
    f1.write_text("print('hi')")
    tree = build_tree(tmp_path, include=["*.py"], exclude=[])
    tree_str = "\n".join(tree)
    assert "file1.py" in tree_str

#[FILE] tests\test_writer.py
from snib.writer import Writer
import pytest

def test_write_and_clear(tmp_path):
    writer = Writer(tmp_path)
    chunks = ["chunk1", "chunk2"]
    files = writer.write_chunks(chunks, force=True, ask_user=False)
    assert len(files) == 2
    for f in files:
        assert f.exists()
    # Clear output
    writer.clear_output()
    assert not any(tmp_path.glob("prompt_*.txt"))


#[FILE] src\snib\chunker.py
import logging

logger = logging.getLogger(__name__)

class Chunker:
    def __init__(self, chunk_size):
        self.chunk_size = chunk_size
        self.header_size = 100  # reserve space for header

    def chunk(self, sections):

        logger.info(f"Using chunk_size={self.chunk_size} chars "
                    f"(≈ {self.chunk_size // 4}-{self.chunk_size // 3} tokens estimated)")

        chunks = []
        current_chunk = ""
        for section in sections:
            lines = section.splitlines(keepends=True)
            for line in lines:
                if len(current_chunk) + len(line) + self.header_size > self.chunk_size:
                    chunks.append(current_chunk)
                    current_chunk = ""
                current_chunk += line
        if current_chunk:
            chunks.append(current_chunk)

        logger.debug(f"Created {len(chunks)} chunk(s)")

        return chunks

#[FILE] src\snib\cli.py
import argparse
from pathlib import Path
import logging

from .scanner import Scanner
from .utils import handle_include_args, handle_exclude_args, detect_pattern_conflicts, check_include_in_exclude
from .constants import SMART_CODE_EXTENSIONS, SMART_IGNORE_EXTENSIONS, DEFAULT_EXCLUDE, TASK_INSTRUCTIONS

logger = logging.getLogger(__name__)

def parse_args():
    parser = argparse.ArgumentParser(
        description="snib scans projects and generates prompt-ready chunks",
        formatter_class=argparse.RawTextHelpFormatter
    )

    # path to scan
    parser.add_argument(
        "--path", "-p",
        nargs="?",
        default=".",
        help="Path to scan (default: current directory)"
    )

    # project description
    parser.add_argument(
        "--description", "-d",
        type=str,
        default="",
        help="Short description of the project and changes you want to make (default: empty string)"
    )

    # include filters
    parser.add_argument(
        "--include", "-i",
        type=str,
        default="all",
        help="Datatypes or folders/files to included, e.g. *.py, cli.py (default: all)"
    )

    # exclude filters
    parser.add_argument(
        "--exclude", "-e",
        type=str,
        default="",
        help="Datatypes or folders/files to excluded, e.g *.pyc, __pycache__ (default: none)"
    )

    # chunk size
    parser.add_argument(
        "--chunk-size", "-c",
        type=int,
        default=30000,
        help=("Max number of characters per chunk (default: 30000)\nRule of thumb: 1 token ≈ 3-4 chars.")
    )

    # output directory (TODO: path and name?)
    parser.add_argument(
        "--output", "-o",
        type=str,
        default="promptready",
        help="Folder to save the prompt ready data chunks (default: 'promptready')"
    )

    # force overwrite
    parser.add_argument(
        "--force", "-f",
        action="store_true",
        help="Force delete existing prompt files and write new ones without validation"
    )

    # predefined tasks
    parser.add_argument(
    "--task", "-t",
    type=str,
    choices=TASK_INSTRUCTIONS.keys(),
    default="",
    help="Select a predefined task for the model, e.g. debug or test (default: none)"
    )

    # info logs
    parser.add_argument(
    "--verbose", "-V",
    action="store_true",
    help="Show INFO logs (default: WARNING only)"
    )

    # debug logs
    parser.add_argument(
        "--dev", "-D",
        action="store_true",
        help="Show DEBUG logs for development (default: WARNING only)"
    )

    # smart mode
    parser.add_argument(
    "--smart", "-s",
    action="store_true",
    help="Smart mode automatically includes only code files and ignores large data/log files"
    )

    # smart default exclude override
    parser.add_argument(
        "--no-default-excludes", "-E",
        action="store_true",
        help="Disable automatic exclusion of venv, promptready, __pycache__ folders"
    )

    return parser.parse_args()

def main():
    args = parse_args()

    # setup logging
    if getattr(args, "dev", False):
        log_level = logging.DEBUG
    elif getattr(args, "verbose", False):
        log_level = logging.INFO
    else:
        log_level = logging.WARNING

    logging.basicConfig(
        level=log_level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
    )

    path = Path(args.path).resolve()
    scanner = Scanner(path)

    # user filters
    user_include = handle_include_args(args.include.split(","))
    user_exclude = handle_exclude_args(args.exclude.split(","))
    logger.debug(f"user_exclude after handle_exclude_args: {user_exclude}")

    # add default excludes automatically unless disabled by user
    if not args.no_default_excludes:
        exclude_patterns = list(set(user_exclude + DEFAULT_EXCLUDE))
        logger.debug(f"Combined exclude patterns: {exclude_patterns}")
    else:
        exclude_patterns = user_exclude

    # combine user filters with smart defaults if smart mode is enabled
    if args.smart:
        include_patterns = list(set(user_include + SMART_CODE_EXTENSIONS))
        exclude_patterns = list(set(exclude_patterns + SMART_IGNORE_EXTENSIONS))
    else:
        include_patterns = user_include
        exclude_patterns = exclude_patterns

    conflicts = detect_pattern_conflicts(include_patterns, exclude_patterns)
    if conflicts:
        logger.warning(f"Pattern conflicts detected (Exclude wins): {conflicts}")
        # optional: del in include_patterns
        include_patterns = [p for p in include_patterns if not any(p in c for c in conflicts)]

    problematic_includes = check_include_in_exclude(path, include_patterns, exclude_patterns)
    if problematic_includes:
        logger.warning(f"The following include patterns are inside excluded folders and will be ignored: {problematic_includes}")
        # optional: del in include_patterns
        include_patterns = [p for p in include_patterns if not any(p in c for c in problematic_includes)]
    
    logger.debug(f"Final include patterns: {include_patterns}")
    logger.debug(f"Final exclude patterns: {exclude_patterns}")

    scanner.scan(
        description=args.description,
        include=include_patterns,
        exclude=exclude_patterns,
        chunk_size=args.chunk_size,
        output_dir=args.output,
        force=args.force,
        task=args.task
    )



#[FILE] src\snib\constants.py
SMART_CODE_EXTENSIONS = [
    "*.py", "*.js", "*.ts", "*.java", "*.cpp", "*.c", "*.cs", "*.go", "*.rb", "*.php",
    "*.html", "*.css", "*.scss", "*.less", "*.json", "*.yaml", "*.yml", "*.xml", "*.sh",
    "*.bat", "*.ps1", "*.pl", "*.swift", "*.kt", "*.m", "*.r", "*.sql"
]

SMART_IGNORE_EXTENSIONS = [
    "*.log", "*.zip", "*.tar", "*.gz", "*.bin", "*.exe", "*.dll", "*.csv"
]

DEFAULT_EXCLUDE = ["venv", "promptready", "__pycache__"]

TASK_INSTRUCTIONS = {
    "debug": "Debug: Analyze the code and highlight potential errors, bugs, or inconsistencies.",
    "comment": "Comment: Add comments or explain existing functions and code sections.",
    "refactor": "Refactor: Suggest refactorings to make the code cleaner, more readable, and maintainable.",
    "optimize": "Optimize: Improve efficiency or performance of the code.",
    "summarize": "Summarize: Provide a concise summary of the files or modules.",
    "document": "Document: Generate documentation for functions, classes, or modules.",
    "test": "Test: Create unit tests or test cases for the code.",
    "analyze": "Analyze: Perform static analysis or security checks on the code."
}

#[FILE] src\snib\formatter.py
import logging

from .models import Section, FilterStats

logger = logging.getLogger(__name__)

class Formatter:
    def to_prompt_text(self, sections: list[Section]) -> list[str]:
        logger.debug("Converting sections to promptready text")
        texts = []
        for s in sections:
            if s.type == "info":
                if s.content:
                    texts.append(f"#[INFO]\n{s.content}\n")
                else:
                    logger.info("Only one prompt file; skipping INFO section.")
            elif s.type == "description":
                if s.content:
                    texts.append(f"#[DESCRIPTION]\n{s.content}\n\n")
                else:
                    logger.info("No description provided; skipping DESCRIPTION section.")
            elif s.type == "task":
                if s.content:
                    texts.append(f"#[TASK]\n{s.content}\n\n")
                else:
                    logger.info("No task specified; skipping TASK section.")
            elif s.type == "filters":
                include_text = s.include if s.include else ""
                exclude_text = s.exclude if s.exclude else ""
                include_stats_text = self._format_stats(s.include_stats) if s.include_stats else ""
                exclude_stats_text = self._format_stats(s.exclude_stats) if s.exclude_stats else ""
                
                texts.append(
                    f"#[INCLUDE/EXCLUDE]\n"
                    f"Include patterns: {include_text}\n"
                    f"Exclude patterns: {exclude_text}\n"
                    f"Included files: {include_stats_text}\n"
                    f"Excluded files: {exclude_stats_text}\n\n"
                )
            elif s.type == "tree":
                texts.append(f"#[PROJECT TREE]\n{s.content}\n\n")
            elif s.type == "file":
                texts.append(f"#[FILE] {s.path}\n{s.content}\n\n")
        return texts
    
    def _format_stats(self, stats: FilterStats) -> str:
        """
        Formats FilterStats readably.
        Shows number of files and total size in B/KB/MB.
        """
        size = stats.size
        if size >= 1024**2:  
            size_str = f"{size / (1024**2):.2f} MB"
        elif size >= 1024:   
            size_str = f"{size / 1024:.2f} KB"
        else:               
            size_str = f"{size} B"

        return f"files: {stats.files}, total size: {size_str}"

#[FILE] src\snib\models.py
from pathlib import Path
from dataclasses import dataclass
from typing import Optional

@dataclass
class FilterStats:
    type: str
    files: int = 0
    size: int = 0

@dataclass
class Section:
    type: str
    content: str = ""   
    path: Optional[Path] = None
    include: Optional[list[str]] = None
    exclude: Optional[list[str]] = None
    include_stats: Optional[FilterStats] = None
    exclude_stats: Optional[FilterStats] = None




#[FILE] src\snib\scanner.py
from pathlib import Path
import logging

from .models import Section, FilterStats
from .formatter import Formatter
from .chunker import Chunker
from .writer import Writer
from .utils import build_tree
from .constants import TASK_INSTRUCTIONS

logger = logging.getLogger(__name__)

class Scanner:
    def __init__(self, path: Path):
        self.path = Path(path).resolve()

    def _collect_sections(self, description, include, exclude, task) -> list[Section]:

        logger.debug("Collecting sections")

        #included_files = self._get_included_files(self.path, include, exclude)
        #excluded_files = self._get_included_files(self.path, exclude, include)
        all_files = [f for f in self.path.rglob("*") if f.is_file()]
        included_files = self._get_included_files(self.path, include, exclude)
        excluded_files = [f for f in all_files if f not in included_files]

        include_stats = self._calculate_filter_stats(included_files, "included")
        exclude_stats = self._calculate_filter_stats(excluded_files, "excluded")

        instruction = TASK_INSTRUCTIONS.get(task, "")

        sections: list[Section] = []

        sections.append(Section(type="description", content=description))
        sections.append(Section(type="task", content=instruction))
        sections.append(Section(type="filters", include=include, exclude=exclude, include_stats=include_stats, exclude_stats=exclude_stats))
        sections.append(Section(type="tree", content="\n".join(build_tree(path=self.path, include=include, exclude=exclude))))

        for file_path in self._get_included_files(self.path, include, exclude):
            try:
                content = file_path.read_text(encoding="utf-8")
            except Exception:
                content = f"<Could not read {file_path.name}>\n"
            sections.append(Section(type="file", path=file_path.relative_to(self.path), content=content))

        logger.debug(f"Collected {len(sections)} sections")

        return sections
    
    """
    def _file_matches_filters(self, path: Path, include: list[str], exclude: list[str]) -> bool:
        for pattern in exclude:
            # file itself or full match
            if path.match(pattern) or path.name == pattern:
                return False
            # NEW: also test folder names in the path!!!
            if any(part == pattern for part in path.parts):
                return False
            
        if include:
            return any(path.match(pattern) or path.name == pattern for pattern in include)

        return True
    """

    def _file_matches_filters(self, path: Path, include: list[str], exclude: list[str]) -> bool:
        for pattern in exclude:
